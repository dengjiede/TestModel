// Created by Microsoft (R) C/C++ Compiler Version 12.00.21005.1 (e26fab5c).
//
// d:\program files (x86)\citymaker 7\citymaker sdk\samples\csharp\beginner\helloworldcplus\debug\GcmRenderControl.tli
//
// Wrapper implementations for Win32 type library 2B31D54F-48C9-445b-8BDC-32A06BAC38FF
// compiler-generated file created 09/08/17 at 15:13:00 - DO NOT EDIT!


//
// interface IRObject wrapper method implementations
//

#pragma implementation_key(1)
inline __int64 IRObject::GetInternalObject ( ) {
    __int64 _result = 0;
    HRESULT _hr = get_InternalObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(2)
inline void IRObject::PutInternalObject ( __int64 pVal ) {
    HRESULT _hr = put_InternalObject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(3)
inline enum gviObjectType IRObject::GetType ( ) {
    enum gviObjectType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(4)
inline GUID IRObject::GetGuid ( ) {
    GUID _result;
    HRESULT _hr = get_Guid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(5)
inline enum gviAttributeMask IRObject::GetAttributeMask ( ) {
    enum gviAttributeMask _result;
    HRESULT _hr = get_AttributeMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(6)
inline void IRObject::PutAttributeMask ( enum gviAttributeMask pVal ) {
    HRESULT _hr = put_AttributeMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(7)
inline HRESULT IRObject::SetClientData ( _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetClientData(Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(8)
inline _bstr_t IRObject::GetClientData ( _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetClientData(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(9)
inline _bstr_t IRObject::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(10)
inline void IRObject::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(11)
inline VARIANT_BOOL IRObject::GetSaveInCepFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SaveInCepFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(12)
inline void IRObject::PutSaveInCepFile ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_SaveInCepFile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderable wrapper method implementations
//

#pragma implementation_key(13)
inline enum gviViewportMask IRenderable::GetVisibleMask ( ) {
    enum gviViewportMask _result;
    HRESULT _hr = get_VisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(14)
inline void IRenderable::PutVisibleMask ( enum gviViewportMask pVal ) {
    HRESULT _hr = put_VisibleMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(15)
inline enum gviViewportMask IRenderable::GetMouseSelectMask ( ) {
    enum gviViewportMask _result;
    HRESULT _hr = get_MouseSelectMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(16)
inline void IRenderable::PutMouseSelectMask ( enum gviViewportMask pVal ) {
    HRESULT _hr = put_MouseSelectMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(17)
inline IEnvelopePtr IRenderable::GetEnvelope ( ) {
    struct IEnvelope * _result = 0;
    HRESULT _hr = get_Envelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnvelopePtr(_result, false);
}

#pragma implementation_key(18)
inline double IRenderable::GetMaxVisibleDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxVisibleDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(19)
inline void IRenderable::PutMaxVisibleDistance ( double pVal ) {
    HRESULT _hr = put_MaxVisibleDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(20)
inline double IRenderable::GetMinVisibleDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_MinVisibleDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(21)
inline void IRenderable::PutMinVisibleDistance ( double pVal ) {
    HRESULT _hr = put_MinVisibleDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(22)
inline float IRenderable::GetMinVisiblePixels ( ) {
    float _result = 0;
    HRESULT _hr = get_MinVisiblePixels(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(23)
inline void IRenderable::PutMinVisiblePixels ( float pVal ) {
    HRESULT _hr = put_MinVisiblePixels(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(24)
inline HRESULT IRenderable::Highlight ( OLE_COLOR Color ) {
    HRESULT _hr = raw_Highlight(Color);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(25)
inline HRESULT IRenderable::Unhighlight ( ) {
    HRESULT _hr = raw_Unhighlight();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(26)
inline double IRenderable::GetViewingDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_ViewingDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(27)
inline void IRenderable::PutViewingDistance ( double pVal ) {
    HRESULT _hr = put_ViewingDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(28)
inline enum gviDepthTestMode IRenderable::GetDepthTestMode ( ) {
    enum gviDepthTestMode _result;
    HRESULT _hr = get_DepthTestMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(29)
inline void IRenderable::PutDepthTestMode ( enum gviDepthTestMode pVal ) {
    HRESULT _hr = put_DepthTestMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderGeometry wrapper method implementations
//

#pragma implementation_key(30)
inline IGeometryPtr IRenderGeometry::GetFdeGeometry ( ) {
    struct IGeometry * _result = 0;
    HRESULT _hr = raw_GetFdeGeometry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryPtr(_result, false);
}

#pragma implementation_key(31)
inline HRESULT IRenderGeometry::SetFdeGeometry ( struct IGeometry * newVal ) {
    HRESULT _hr = raw_SetFdeGeometry(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(32)
inline void IRenderGeometry::PutForceCullMode ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ForceCullMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(33)
inline VARIANT_BOOL IRenderGeometry::GetForceCullMode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ForceCullMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(34)
inline void IRenderGeometry::PutCullMode ( enum gviCullFaceMode pVal ) {
    HRESULT _hr = put_CullMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(35)
inline enum gviCullFaceMode IRenderGeometry::GetCullMode ( ) {
    enum gviCullFaceMode _result;
    HRESULT _hr = get_CullMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(36)
inline HRESULT IRenderGeometry::Glow ( long Duration ) {
    HRESULT _hr = raw_Glow(Duration);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(37)
inline void IRenderGeometry::PutShowOutline ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowOutline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(38)
inline VARIANT_BOOL IRenderGeometry::GetShowOutline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowOutline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(39)
inline _bstr_t IRenderGeometry::GetToolTipText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ToolTipText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(40)
inline void IRenderGeometry::PutToolTipText ( _bstr_t pVal ) {
    HRESULT _hr = put_ToolTipText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IReferencePlane wrapper method implementations
//

#pragma implementation_key(41)
inline double IReferencePlane::GetPlaneHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_PlaneHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(42)
inline void IReferencePlane::PutPlaneHeight ( double pVal ) {
    HRESULT _hr = put_PlaneHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(43)
inline enum gviViewportMask IReferencePlane::GetVisibleMask ( ) {
    enum gviViewportMask _result;
    HRESULT _hr = get_VisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(44)
inline void IReferencePlane::PutVisibleMask ( enum gviViewportMask pVal ) {
    HRESULT _hr = put_VisibleMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IFeatureManager wrapper method implementations
//

#pragma implementation_key(45)
inline VARIANT_BOOL IFeatureManager::CreateFeatures ( struct IFeatureClass * FeatureClass, struct IRowBufferCollection * RowBuffers ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CreateFeatures(FeatureClass, RowBuffers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(46)
inline VARIANT_BOOL IFeatureManager::CreateFeature ( struct IFeatureClass * FeatureClass, struct IRowBuffer * RowBuffer ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CreateFeature(FeatureClass, RowBuffer, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(47)
inline VARIANT_BOOL IFeatureManager::EditFeatures ( struct IFeatureClass * FeatureClass, struct IRowBufferCollection * RowBuffers ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_EditFeatures(FeatureClass, RowBuffers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(48)
inline VARIANT_BOOL IFeatureManager::EditFeature ( struct IFeatureClass * FeatureClass, struct IRowBuffer * RowBuffer ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_EditFeature(FeatureClass, RowBuffer, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(49)
inline VARIANT_BOOL IFeatureManager::DeleteFeatures ( struct IFeatureClass * FeatureClass, SAFEARRAY * Ids ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteFeatures(FeatureClass, Ids, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(50)
inline VARIANT_BOOL IFeatureManager::DeleteFeature ( struct IFeatureClass * FeatureClass, long FeatureId ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteFeature(FeatureClass, FeatureId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(51)
inline VARIANT_BOOL IFeatureManager::HighlightFeature ( struct IFeatureClass * FeatureClass, long FeatureId, OLE_COLOR ColorValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HighlightFeature(FeatureClass, FeatureId, ColorValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(52)
inline VARIANT_BOOL IFeatureManager::UnhighlightFeature ( struct IFeatureClass * FeatureClass, long FeatureId ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnhighlightFeature(FeatureClass, FeatureId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(53)
inline VARIANT_BOOL IFeatureManager::UnhighlightFeatureClass ( struct IFeatureClass * FeatureClass ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnhighlightFeatureClass(FeatureClass, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(54)
inline VARIANT_BOOL IFeatureManager::UnhighlightAll ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_UnhighlightAll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(55)
inline HRESULT IFeatureManager::RefreshFeatureClass ( struct IFeatureClass * FeatureClass ) {
    HRESULT _hr = raw_RefreshFeatureClass(FeatureClass);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(56)
inline HRESULT IFeatureManager::RefreshAll ( ) {
    HRESULT _hr = raw_RefreshAll();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(57)
inline VARIANT_BOOL IFeatureManager::SetFeatureVisibleMask ( struct IFeatureClass * FeatureClass, long FeatureId, enum gviViewportMask VisibleMask ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetFeatureVisibleMask(FeatureClass, FeatureId, VisibleMask, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(58)
inline VARIANT_BOOL IFeatureManager::SetFeaturesVisibleMask ( struct IFeatureClass * FeatureClass, SAFEARRAY * FIDs, enum gviViewportMask VisibleMask ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetFeaturesVisibleMask(FeatureClass, FIDs, VisibleMask, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(59)
inline VARIANT_BOOL IFeatureManager::ResetFeatureVisibleMask ( struct IFeatureClass * FeatureClass, long FeatureId ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ResetFeatureVisibleMask(FeatureClass, FeatureId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(60)
inline VARIANT_BOOL IFeatureManager::ResetFeatureClassVisibleMask ( struct IFeatureClass * FeatureClass ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ResetFeatureClassVisibleMask(FeatureClass, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(61)
inline VARIANT_BOOL IFeatureManager::ResetAllVisibleMask ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ResetAllVisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(62)
inline VARIANT_BOOL IFeatureManager::HighlightFeatures ( struct IFeatureClass * FeatureClass, SAFEARRAY * FIDs, OLE_COLOR ColorValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_HighlightFeatures(FeatureClass, FIDs, ColorValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPickResult wrapper method implementations
//

#pragma implementation_key(63)
inline enum gviObjectType IPickResult::GetType ( ) {
    enum gviObjectType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPickResultCollection wrapper method implementations
//

#pragma implementation_key(64)
inline long IPickResultCollection::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(65)
inline IPickResultPtr IPickResultCollection::GetItem ( long n ) {
    struct IPickResult * _result = 0;
    HRESULT _hr = get_Item(n, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPickResultPtr(_result, false);
}

//
// interface ITransformHelper wrapper method implementations
//

#pragma implementation_key(66)
inline enum gviEditorType ITransformHelper::GetType ( ) {
    enum gviEditorType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(67)
inline void ITransformHelper::PutType ( enum gviEditorType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(68)
inline HRESULT ITransformHelper::SetPosition ( struct IVector3 * Position ) {
    HRESULT _hr = raw_SetPosition(Position);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(69)
inline _bstr_t ITransformHelper::GetCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(70)
inline void ITransformHelper::PutCrsWKT ( _bstr_t pVal ) {
    HRESULT _hr = put_CrsWKT(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(71)
inline HRESULT ITransformHelper::SetPosition2 ( struct IVector3 * Position, struct IEulerAngle * Angle ) {
    HRESULT _hr = raw_SetPosition2(Position, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(72)
inline HRESULT ITransformHelper::SetPosition3 ( struct IEnvelope * Env, struct IEulerAngle * Angle ) {
    HRESULT _hr = raw_SetPosition3(Env, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ICamera wrapper method implementations
//

#pragma implementation_key(73)
inline HRESULT ICamera::LookAt ( struct IVector3 * Position, double Distance, struct IEulerAngle * Angle ) {
    HRESULT _hr = raw_LookAt(Position, Distance, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(74)
inline HRESULT ICamera::LookAt2 ( struct IPoint * Position, double Distance, struct IEulerAngle * Angle ) {
    HRESULT _hr = raw_LookAt2(Position, Distance, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(75)
inline HRESULT ICamera::SetCamera ( struct IVector3 * Position, struct IEulerAngle * Angle, enum gviSetCameraFlags Flags ) {
    HRESULT _hr = raw_SetCamera(Position, Angle, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(76)
inline HRESULT ICamera::SetCamera2 ( struct IPoint * Position, struct IEulerAngle * Angle, enum gviSetCameraFlags Flags ) {
    HRESULT _hr = raw_SetCamera2(Position, Angle, Flags);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(77)
inline HRESULT ICamera::GetCamera ( struct IVector3 * * Position, struct IEulerAngle * * Angle ) {
    HRESULT _hr = raw_GetCamera(Position, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(78)
inline HRESULT ICamera::GetCamera2 ( struct IPoint * * Position, struct IEulerAngle * * Angle ) {
    HRESULT _hr = raw_GetCamera2(Position, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(79)
inline double ICamera::GetFlyTime ( ) {
    double _result = 0;
    HRESULT _hr = get_FlyTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(80)
inline void ICamera::PutFlyTime ( double pVal ) {
    HRESULT _hr = put_FlyTime(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(81)
inline IEulerAnglePtr ICamera::GetAimingAngles ( struct IVector3 * Position1, struct IVector3 * Position2 ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = raw_GetAimingAngles(Position1, Position2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(82)
inline IEulerAnglePtr ICamera::GetAimingAngles2 ( struct IPoint * Position1, struct IPoint * Position2 ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = raw_GetAimingAngles2(Position1, Position2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(83)
inline IVector3Ptr ICamera::GetAimingPoint ( struct IVector3 * Position, struct IEulerAngle * Angle, double Range ) {
    struct IVector3 * _result = 0;
    HRESULT _hr = raw_GetAimingPoint(Position, Angle, Range, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVector3Ptr(_result, false);
}

#pragma implementation_key(84)
inline IPointPtr ICamera::GetAimingPoint2 ( struct IPoint * Position, struct IEulerAngle * Angle, double Range ) {
    struct IPoint * _result = 0;
    HRESULT _hr = raw_GetAimingPoint2(Position, Angle, Range, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(85)
inline HRESULT ICamera::LookAtEnvelope ( struct IEnvelope * Env ) {
    HRESULT _hr = raw_LookAtEnvelope(Env);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(86)
inline HRESULT ICamera::LookAtEnvelope2 ( _bstr_t CrsWKT, struct IEnvelope * Env ) {
    HRESULT _hr = raw_LookAtEnvelope2(CrsWKT, Env);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(87)
inline IMatrixPtr ICamera::AsMatrix ( ) {
    struct IMatrix * _result = 0;
    HRESULT _hr = raw_AsMatrix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMatrixPtr(_result, false);
}

#pragma implementation_key(88)
inline HRESULT ICamera::FromMatrix ( struct IMatrix * newVal ) {
    HRESULT _hr = raw_FromMatrix(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(89)
inline float ICamera::GetVerticalFieldOfView ( ) {
    float _result = 0;
    HRESULT _hr = get_VerticalFieldOfView(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(90)
inline void ICamera::PutVerticalFieldOfView ( float pVal ) {
    HRESULT _hr = put_VerticalFieldOfView(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(91)
inline float ICamera::GetWalkSpeed ( ) {
    float _result = 0;
    HRESULT _hr = get_WalkSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(92)
inline void ICamera::PutWalkSpeed ( float pVal ) {
    HRESULT _hr = put_WalkSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(93)
inline float ICamera::GetFlySpeed ( ) {
    float _result = 0;
    HRESULT _hr = get_FlySpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(94)
inline void ICamera::PutFlySpeed ( float pVal ) {
    HRESULT _hr = put_FlySpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(95)
inline enum gviFlyMode ICamera::GetFlyMode ( ) {
    enum gviFlyMode _result;
    HRESULT _hr = get_FlyMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(96)
inline void ICamera::PutFlyMode ( enum gviFlyMode pVal ) {
    HRESULT _hr = put_FlyMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(97)
inline float ICamera::GetNearClipPlane ( ) {
    float _result = 0;
    HRESULT _hr = get_NearClipPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(98)
inline void ICamera::PutNearClipPlane ( float pVal ) {
    HRESULT _hr = put_NearClipPlane(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(99)
inline float ICamera::GetFarClipPlane ( ) {
    float _result = 0;
    HRESULT _hr = get_FarClipPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(100)
inline void ICamera::PutFarClipPlane ( float pVal ) {
    HRESULT _hr = put_FarClipPlane(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(101)
inline VARIANT_BOOL ICamera::GetAutoClipPlane ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoClipPlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(102)
inline void ICamera::PutAutoClipPlane ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoClipPlane(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(103)
inline HRESULT ICamera::FlyToObject ( GUID ObjectId, enum gviActionCode ActionCode ) {
    HRESULT _hr = raw_FlyToObject(ObjectId, ActionCode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(104)
inline IPickResultPtr ICamera::ScreenToWorld ( long WindowX, long WindowY, struct IPoint * * IntersectPoint ) {
    struct IPickResult * _result = 0;
    HRESULT _hr = raw_ScreenToWorld(WindowX, WindowY, IntersectPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPickResultPtr(_result, false);
}

#pragma implementation_key(105)
inline enum gviCollisionDetectionMode ICamera::GetCollisionDetectionMode ( ) {
    enum gviCollisionDetectionMode _result;
    HRESULT _hr = get_CollisionDetectionMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(106)
inline void ICamera::PutCollisionDetectionMode ( enum gviCollisionDetectionMode pVal ) {
    HRESULT _hr = put_CollisionDetectionMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(107)
inline VARIANT_BOOL ICamera::GetCanUndo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanUndo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(108)
inline VARIANT_BOOL ICamera::GetCanRedo ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanRedo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(109)
inline HRESULT ICamera::Undo ( ) {
    HRESULT _hr = raw_Undo();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(110)
inline HRESULT ICamera::Redo ( ) {
    HRESULT _hr = raw_Redo();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(111)
inline HRESULT ICamera::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(112)
inline float ICamera::GetWalkHeight ( ) {
    float _result = 0;
    HRESULT _hr = get_WalkHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(113)
inline void ICamera::PutWalkHeight ( float pVal ) {
    HRESULT _hr = put_WalkHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(114)
inline enum gviWalkMode ICamera::GetWalkMode ( ) {
    enum gviWalkMode _result;
    HRESULT _hr = get_WalkMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(115)
inline void ICamera::PutWalkMode ( enum gviWalkMode pVal ) {
    HRESULT _hr = put_WalkMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(116)
inline VARIANT_BOOL ICamera::WorldToScreen ( double WorldX, double WorldY, double WorldZ, double * ScreenX, double * ScreenY, int Mode, VARIANT_BOOL * BoolInScreen ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_WorldToScreen(WorldX, WorldY, WorldZ, ScreenX, ScreenY, Mode, BoolInScreen, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(117)
inline IEnvelopePtr ICamera::GetEnvelope ( ) {
    struct IEnvelope * _result = 0;
    HRESULT _hr = get_Envelope(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEnvelopePtr(_result, false);
}

#pragma implementation_key(118)
inline void ICamera::PutEnvelope ( struct IEnvelope * pVal ) {
    HRESULT _hr = put_Envelope(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(119)
inline VARIANT_BOOL ICamera::GetUndergroundMode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_UndergroundMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(120)
inline void ICamera::PutUndergroundMode ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_UndergroundMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(121)
inline HRESULT ICamera::ZoomIn ( float Delta ) {
    HRESULT _hr = raw_ZoomIn(Delta);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(122)
inline HRESULT ICamera::ZoomOut ( float Delta ) {
    HRESULT _hr = raw_ZoomOut(Delta);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ITerrain wrapper method implementations
//

#pragma implementation_key(123)
inline VARIANT_BOOL ITerrain::RegisterTerrain ( _bstr_t LayerInfo, _bstr_t Password ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_RegisterTerrain(LayerInfo, Password, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(124)
inline VARIANT_BOOL ITerrain::GetIsPlanarTerrain ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPlanarTerrain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(125)
inline HRESULT ITerrain::UnregisterTerrain ( ) {
    HRESULT _hr = raw_UnregisterTerrain();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(126)
inline _bstr_t ITerrain::GetCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(127)
inline double ITerrain::GetElevation ( double X, double Y, enum gviGetElevationType GetAltitudeType ) {
    double _result = 0;
    HRESULT _hr = raw_GetElevation(X, Y, GetAltitudeType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(128)
inline VARIANT_BOOL ITerrain::GetDemAvailable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DemAvailable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(129)
inline void ITerrain::PutDemAvailable ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DemAvailable(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(130)
inline enum gviViewportMask ITerrain::GetVisibleMask ( ) {
    enum gviViewportMask _result;
    HRESULT _hr = get_VisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(131)
inline void ITerrain::PutVisibleMask ( enum gviViewportMask pVal ) {
    HRESULT _hr = put_VisibleMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(132)
inline VARIANT_BOOL ITerrain::GetIsRegistered ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsRegistered(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(133)
inline HRESULT ITerrain::FlyTo ( enum gviTerrainActionCode newVal ) {
    HRESULT _hr = raw_FlyTo(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(134)
inline double ITerrain::GetOpacity ( ) {
    double _result = 0;
    HRESULT _hr = get_Opacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(135)
inline void ITerrain::PutOpacity ( double pVal ) {
    HRESULT _hr = put_Opacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(136)
inline IPolylinePtr ITerrain::FindBestPath ( double StartX, double StartY, double EndX, double EndY, long SampleNumber, double SearchAreaFactor, double MaxClimbSlope, double MaxDescentSlope ) {
    struct IPolyline * _result = 0;
    HRESULT _hr = raw_FindBestPath(StartX, StartY, EndX, EndY, SampleNumber, SearchAreaFactor, MaxClimbSlope, MaxDescentSlope, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPolylinePtr(_result, false);
}

#pragma implementation_key(137)
inline IEulerAnglePtr ITerrain::GetSlope ( double X, double Y ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = raw_GetSlope(X, Y, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(138)
inline VARIANT_BOOL ITerrain::GetSupportAtmosphere ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_SupportAtmosphere(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(139)
inline VARIANT_BOOL ITerrain::GetEnableAtmosphere ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableAtmosphere(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(140)
inline void ITerrain::PutEnableAtmosphere ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableAtmosphere(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(141)
inline HRESULT ITerrain::SetInvisibleRegion ( struct IMultiPolygon * Region ) {
    HRESULT _hr = raw_SetInvisibleRegion(Region);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(142)
inline IMultiPolygonPtr ITerrain::GetInvisibleRegion ( ) {
    struct IMultiPolygon * _result = 0;
    HRESULT _hr = raw_GetInvisibleRegion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMultiPolygonPtr(_result, false);
}

#pragma implementation_key(143)
inline HRESULT ITerrain::SetOceanRegion ( struct IMultiPolygon * Region ) {
    HRESULT _hr = raw_SetOceanRegion(Region);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(144)
inline IMultiPolygonPtr ITerrain::GetOceanRegion ( ) {
    struct IMultiPolygon * _result = 0;
    HRESULT _hr = raw_GetOceanRegion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMultiPolygonPtr(_result, false);
}

#pragma implementation_key(145)
inline VARIANT_BOOL ITerrain::GetEnableOceanEffect ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableOceanEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(146)
inline void ITerrain::PutEnableOceanEffect ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableOceanEffect(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(147)
inline double ITerrain::GetOceanWindSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_OceanWindSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(148)
inline void ITerrain::PutOceanWindSpeed ( double pVal ) {
    HRESULT _hr = put_OceanWindSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(149)
inline double ITerrain::GetOceanWindDirection ( ) {
    double _result = 0;
    HRESULT _hr = get_OceanWindDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(150)
inline void ITerrain::PutOceanWindDirection ( double pVal ) {
    HRESULT _hr = put_OceanWindDirection(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(151)
inline _bstr_t ITerrain::GetConnectInfo ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConnectInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ISkyBox wrapper method implementations
//

#pragma implementation_key(152)
inline OLE_COLOR ISkyBox::GetBackgroundColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackgroundColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(153)
inline void ISkyBox::PutBackgroundColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackgroundColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(154)
inline double ISkyBox::GetHeading ( ) {
    double _result = 0;
    HRESULT _hr = get_Heading(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(155)
inline void ISkyBox::PutHeading ( double pVal ) {
    HRESULT _hr = put_Heading(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(156)
inline HRESULT ISkyBox::SetImagePath ( enum gviSkyboxImageIndex ImageIndex, _bstr_t ImagePath ) {
    HRESULT _hr = raw_SetImagePath(ImageIndex, ImagePath);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(157)
inline _bstr_t ISkyBox::GetImagePath ( enum gviSkyboxImageIndex ImageIndex ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetImagePath(ImageIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(158)
inline enum gviFogMode ISkyBox::GetFogMode ( ) {
    enum gviFogMode _result;
    HRESULT _hr = get_FogMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(159)
inline void ISkyBox::PutFogMode ( enum gviFogMode pVal ) {
    HRESULT _hr = put_FogMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(160)
inline OLE_COLOR ISkyBox::GetFogColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_FogColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(161)
inline void ISkyBox::PutFogColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_FogColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(162)
inline float ISkyBox::GetFogStartDistance ( ) {
    float _result = 0;
    HRESULT _hr = get_FogStartDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(163)
inline void ISkyBox::PutFogStartDistance ( float pVal ) {
    HRESULT _hr = put_FogStartDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(164)
inline float ISkyBox::GetFogEndDistance ( ) {
    float _result = 0;
    HRESULT _hr = get_FogEndDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(165)
inline void ISkyBox::PutFogEndDistance ( float pVal ) {
    HRESULT _hr = put_FogEndDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(166)
inline enum gviWeatherType ISkyBox::GetWeather ( ) {
    enum gviWeatherType _result;
    HRESULT _hr = get_Weather(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(167)
inline void ISkyBox::PutWeather ( enum gviWeatherType pVal ) {
    HRESULT _hr = put_Weather(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITextRender wrapper method implementations
//

#pragma implementation_key(168)
inline __int64 ITextRender::GetInternalObject ( ) {
    __int64 _result = 0;
    HRESULT _hr = get_InternalObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(169)
inline void ITextRender::PutInternalObject ( __int64 pVal ) {
    HRESULT _hr = put_InternalObject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(170)
inline _bstr_t ITextRender::GetExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Expression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(171)
inline void ITextRender::PutExpression ( _bstr_t pVal ) {
    HRESULT _hr = put_Expression(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(172)
inline enum gviRenderType ITextRender::GetRenderType ( ) {
    enum gviRenderType _result;
    HRESULT _hr = get_RenderType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(173)
inline VARIANT_BOOL ITextRender::GetDynamicPlacement ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DynamicPlacement(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(174)
inline void ITextRender::PutDynamicPlacement ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DynamicPlacement(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(175)
inline VARIANT_BOOL ITextRender::GetMinimizeOverlap ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MinimizeOverlap(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(176)
inline void ITextRender::PutMinimizeOverlap ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MinimizeOverlap(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(177)
inline VARIANT_BOOL ITextRender::GetRemoveDuplicate ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RemoveDuplicate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(178)
inline void ITextRender::PutRemoveDuplicate ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RemoveDuplicate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(179)
inline _bstr_t ITextRender::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IGeometryRender wrapper method implementations
//

#pragma implementation_key(180)
inline __int64 IGeometryRender::GetInternalObject ( ) {
    __int64 _result = 0;
    HRESULT _hr = get_InternalObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(181)
inline void IGeometryRender::PutInternalObject ( __int64 pVal ) {
    HRESULT _hr = put_InternalObject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(182)
inline _bstr_t IGeometryRender::GetRenderGroupField ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RenderGroupField(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(183)
inline void IGeometryRender::PutRenderGroupField ( _bstr_t pVal ) {
    HRESULT _hr = put_RenderGroupField(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(184)
inline enum gviRenderType IGeometryRender::GetRenderType ( ) {
    enum gviRenderType _result;
    HRESULT _hr = get_RenderType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(185)
inline enum gviHeightStyle IGeometryRender::GetHeightStyle ( ) {
    enum gviHeightStyle _result;
    HRESULT _hr = get_HeightStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(186)
inline void IGeometryRender::PutHeightStyle ( enum gviHeightStyle pVal ) {
    HRESULT _hr = put_HeightStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(187)
inline double IGeometryRender::GetHeightOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_HeightOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(188)
inline void IGeometryRender::PutHeightOffset ( double pVal ) {
    HRESULT _hr = put_HeightOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(189)
inline _bstr_t IGeometryRender::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IFeatureClassInfo wrapper method implementations
//

#pragma implementation_key(190)
inline _bstr_t IFeatureClassInfo::GetDataSourceConnectionString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DataSourceConnectionString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(191)
inline _bstr_t IFeatureClassInfo::GetDataSetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DataSetName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(192)
inline _bstr_t IFeatureClassInfo::GetFeatureClassName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FeatureClassName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(193)
inline _bstr_t IFeatureClassInfo::GetFidFieldName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FidFieldName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IFeatureLayer wrapper method implementations
//

#pragma implementation_key(194)
inline HRESULT IFeatureLayer::SetGroupVisibleMask ( long GroupId, enum gviViewportMask VisibleMask ) {
    HRESULT _hr = raw_SetGroupVisibleMask(GroupId, VisibleMask);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(195)
inline enum gviViewportMask IFeatureLayer::GetGroupVisibleMask ( long GroupId ) {
    enum gviViewportMask _result;
    HRESULT _hr = raw_GetGroupVisibleMask(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(196)
inline GUID IFeatureLayer::GetFeatureClassId ( ) {
    GUID _result;
    HRESULT _hr = get_FeatureClassId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(197)
inline _bstr_t IFeatureLayer::GetGeometryFieldName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_GeometryFieldName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(198)
inline ITextRenderPtr IFeatureLayer::GetTextRender ( ) {
    struct ITextRender * _result = 0;
    HRESULT _hr = raw_GetTextRender(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextRenderPtr(_result, false);
}

#pragma implementation_key(199)
inline VARIANT_BOOL IFeatureLayer::SetTextRender ( struct ITextRender * newVal ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetTextRender(newVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(200)
inline IGeometryRenderPtr IFeatureLayer::GetGeometryRender ( ) {
    struct IGeometryRender * _result = 0;
    HRESULT _hr = raw_GetGeometryRender(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryRenderPtr(_result, false);
}

#pragma implementation_key(201)
inline VARIANT_BOOL IFeatureLayer::SetGeometryRender ( struct IGeometryRender * newVal ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetGeometryRender(newVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(202)
inline HRESULT IFeatureLayer::SetEnableGroupColor ( long GroupId, VARIANT_BOOL newVal ) {
    HRESULT _hr = raw_SetEnableGroupColor(GroupId, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(203)
inline VARIANT_BOOL IFeatureLayer::GetEnableGroupColor ( long GroupId ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetEnableGroupColor(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(204)
inline HRESULT IFeatureLayer::SetGroupColor ( long GroupId, OLE_COLOR newVal ) {
    HRESULT _hr = raw_SetGroupColor(GroupId, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(205)
inline OLE_COLOR IFeatureLayer::GetGroupColor ( long GroupId ) {
    OLE_COLOR _result;
    HRESULT _hr = raw_GetGroupColor(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(206)
inline void IFeatureLayer::PutForceCullMode ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ForceCullMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(207)
inline VARIANT_BOOL IFeatureLayer::GetForceCullMode ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ForceCullMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(208)
inline void IFeatureLayer::PutCullMode ( enum gviCullFaceMode pVal ) {
    HRESULT _hr = put_CullMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(209)
inline enum gviCullFaceMode IFeatureLayer::GetCullMode ( ) {
    enum gviCullFaceMode _result;
    HRESULT _hr = get_CullMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(210)
inline void IFeatureLayer::PutEnableTemporal ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableTemporal(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(211)
inline VARIANT_BOOL IFeatureLayer::GetEnableTemporal ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableTemporal(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(212)
inline DATE IFeatureLayer::GetTime ( ) {
    DATE _result = 0;
    HRESULT _hr = get_Time(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(213)
inline void IFeatureLayer::PutTime ( DATE pVal ) {
    HRESULT _hr = put_Time(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(214)
inline long IFeatureLayer::GetDrawOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_DrawOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(215)
inline void IFeatureLayer::PutDrawOrder ( long pVal ) {
    HRESULT _hr = put_DrawOrder(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(216)
inline enum gviGeometryColumnType IFeatureLayer::GetGeometryType ( ) {
    enum gviGeometryColumnType _result;
    HRESULT _hr = get_GeometryType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(217)
inline _bstr_t IFeatureLayer::GetWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(218)
inline IFeatureClassInfoPtr IFeatureLayer::GetFeatureClassInfo ( ) {
    struct IFeatureClassInfo * _result = 0;
    HRESULT _hr = get_FeatureClassInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFeatureClassInfoPtr(_result, false);
}

#pragma implementation_key(219)
inline SAFEARRAY * IFeatureLayer::GetHiddenFeatures ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_HiddenFeatures(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(220)
inline void IFeatureLayer::PutHiddenFeatures ( SAFEARRAY * pVal ) {
    HRESULT _hr = put_HiddenFeatures(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainRoute wrapper method implementations
//

#pragma implementation_key(221)
inline VARIANT_BOOL ITerrainRoute::AddWaypoint ( struct IVector3 * Position, struct IEulerAngle * Angle, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddWaypoint(Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(222)
inline VARIANT_BOOL ITerrainRoute::AddWaypoint2 ( struct IPoint * Position, struct IEulerAngle * Angle, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddWaypoint2(Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(223)
inline VARIANT_BOOL ITerrainRoute::ModifyWaypoint ( long Index, struct IVector3 * Position, struct IEulerAngle * Angle, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ModifyWaypoint(Index, Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(224)
inline VARIANT_BOOL ITerrainRoute::ModifyWaypoint2 ( long Index, struct IPoint * Position, struct IEulerAngle * Angle, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ModifyWaypoint2(Index, Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(225)
inline VARIANT_BOOL ITerrainRoute::InsertWaypoint ( long Index, struct IVector3 * Position, struct IEulerAngle * Angle, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InsertWaypoint(Index, Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(226)
inline VARIANT_BOOL ITerrainRoute::InsertWaypoint2 ( long Index, struct IPoint * Position, struct IEulerAngle * Angle, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InsertWaypoint2(Index, Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(227)
inline VARIANT_BOOL ITerrainRoute::GetWaypoint ( long Index, struct IVector3 * * Position, struct IEulerAngle * * Angle, double * Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetWaypoint(Index, Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(228)
inline VARIANT_BOOL ITerrainRoute::GetWaypoint2 ( long Index, struct IPoint * * Position, struct IEulerAngle * * Angle, double * Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetWaypoint2(Index, Position, Angle, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(229)
inline VARIANT_BOOL ITerrainRoute::DeleteWaypoint ( long Index ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteWaypoint(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(230)
inline long ITerrainRoute::GetWaypointsNumber ( ) {
    long _result = 0;
    HRESULT _hr = get_WaypointsNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(231)
inline HRESULT ITerrainRoute::Play ( ) {
    HRESULT _hr = raw_Play();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(232)
inline HRESULT ITerrainRoute::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(233)
inline HRESULT ITerrainRoute::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(234)
inline VARIANT_BOOL ITerrainRoute::GetAutoRepeat ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoRepeat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(235)
inline void ITerrainRoute::PutAutoRepeat ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoRepeat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(236)
inline VARIANT_BOOL ITerrainRoute::AddWaypointByMatrix ( struct IMatrix * Mat, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddWaypointByMatrix(Mat, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(237)
inline VARIANT_BOOL ITerrainRoute::GetWaypointByMatrix ( long Index, struct IMatrix * * Mat, double * Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetWaypointByMatrix(Index, Mat, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(238)
inline VARIANT_BOOL ITerrainRoute::ModifyWaypointByMatrix ( long Index, struct IMatrix * Mat, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ModifyWaypointByMatrix(Index, Mat, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(239)
inline VARIANT_BOOL ITerrainRoute::InsertWaypointByMatrix ( long Index, struct IMatrix * Mat, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InsertWaypointByMatrix(Index, Mat, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(240)
inline HRESULT ITerrainRoute::ExportVideo ( _bstr_t FilePath, long FPS ) {
    HRESULT _hr = raw_ExportVideo(FilePath, FPS);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(241)
inline HRESULT ITerrainRoute::CancelExport ( ) {
    HRESULT _hr = raw_CancelExport();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(242)
inline VARIANT_BOOL ITerrainRoute::GetIsExporting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExporting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(243)
inline _bstr_t ITerrainRoute::GetCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(244)
inline void ITerrainRoute::PutCrsWKT ( _bstr_t pVal ) {
    HRESULT _hr = put_CrsWKT(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(245)
inline _bstr_t ITerrainRoute::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(246)
inline VARIANT_BOOL ITerrainRoute::FromXml ( _bstr_t XmlStringValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FromXml(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(247)
inline _bstr_t ITerrainRoute::GetSlideImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SlideImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(248)
inline void ITerrainRoute::PutSlideImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_SlideImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IGeometrySymbol wrapper method implementations
//

#pragma implementation_key(249)
inline __int64 IGeometrySymbol::GetInternalObject ( ) {
    __int64 _result = 0;
    HRESULT _hr = get_InternalObject(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(250)
inline void IGeometrySymbol::PutInternalObject ( __int64 pVal ) {
    HRESULT _hr = put_InternalObject(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(251)
inline enum gviGeometrySymbolType IGeometrySymbol::GetSymbolType ( ) {
    enum gviGeometrySymbolType _result;
    HRESULT _hr = get_SymbolType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(252)
inline HRESULT IGeometrySymbol::SetResourceDataSet ( struct IFeatureDataSet * DataSet ) {
    HRESULT _hr = raw_SetResourceDataSet(DataSet);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(253)
inline _bstr_t IGeometrySymbol::GetScript ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Script(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(254)
inline void IGeometrySymbol::PutScript ( _bstr_t pVal ) {
    HRESULT _hr = put_Script(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(255)
inline _bstr_t IGeometrySymbol::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IModelPointSymbol wrapper method implementations
//

#pragma implementation_key(256)
inline OLE_COLOR IModelPointSymbol::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(257)
inline void IModelPointSymbol::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(258)
inline VARIANT_BOOL IModelPointSymbol::GetEnableTexture ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableTexture(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(259)
inline void IModelPointSymbol::PutEnableTexture ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableTexture(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(260)
inline VARIANT_BOOL IModelPointSymbol::GetEnableColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(261)
inline void IModelPointSymbol::PutEnableColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderModelPoint wrapper method implementations
//

#pragma implementation_key(262)
inline IModelPointSymbolPtr IRenderModelPoint::GetSymbol ( ) {
    struct IModelPointSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IModelPointSymbolPtr(_result, false);
}

#pragma implementation_key(263)
inline void IRenderModelPoint::PutSymbol ( struct IModelPointSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(264)
inline IVector3Ptr IRenderModelPoint::GetPosition ( ) {
    struct IVector3 * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVector3Ptr(_result, false);
}

#pragma implementation_key(265)
inline void IRenderModelPoint::PutPosition ( struct IVector3 * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(266)
inline SAFEARRAY * IRenderModelPoint::GetMatrix ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Matrix(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(267)
inline void IRenderModelPoint::PutMatrix ( SAFEARRAY * pVal ) {
    HRESULT _hr = put_Matrix(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(268)
inline _bstr_t IRenderModelPoint::GetModelName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ModelName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ICurveSymbol wrapper method implementations
//

#pragma implementation_key(269)
inline OLE_COLOR ICurveSymbol::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(270)
inline void ICurveSymbol::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(271)
inline float ICurveSymbol::GetWidth ( ) {
    float _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(272)
inline void ICurveSymbol::PutWidth ( float pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(273)
inline float ICurveSymbol::GetRepeatLength ( ) {
    float _result = 0;
    HRESULT _hr = get_RepeatLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(274)
inline void ICurveSymbol::PutRepeatLength ( float pVal ) {
    HRESULT _hr = put_RepeatLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(275)
inline _bstr_t ICurveSymbol::GetImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(276)
inline void ICurveSymbol::PutImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_ImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(277)
inline OLE_COLOR ICurveSymbol::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(278)
inline void ICurveSymbol::PutBackColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(279)
inline enum gviDashStyle ICurveSymbol::GetPattern ( ) {
    enum gviDashStyle _result;
    HRESULT _hr = get_Pattern(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(280)
inline void ICurveSymbol::PutPattern ( enum gviDashStyle pVal ) {
    HRESULT _hr = put_Pattern(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderPolyline wrapper method implementations
//

#pragma implementation_key(281)
inline ICurveSymbolPtr IRenderPolyline::GetSymbol ( ) {
    struct ICurveSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICurveSymbolPtr(_result, false);
}

#pragma implementation_key(282)
inline void IRenderPolyline::PutSymbol ( struct ICurveSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(283)
inline enum gviHeightStyle IRenderPolyline::GetHeightStyle ( ) {
    enum gviHeightStyle _result;
    HRESULT _hr = get_HeightStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(284)
inline void IRenderPolyline::PutHeightStyle ( enum gviHeightStyle pVal ) {
    HRESULT _hr = put_HeightStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISurfaceSymbol wrapper method implementations
//

#pragma implementation_key(285)
inline OLE_COLOR ISurfaceSymbol::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(286)
inline void ISurfaceSymbol::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(287)
inline ICurveSymbolPtr ISurfaceSymbol::GetBoundarySymbol ( ) {
    struct ICurveSymbol * _result = 0;
    HRESULT _hr = get_BoundarySymbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICurveSymbolPtr(_result, false);
}

#pragma implementation_key(288)
inline void ISurfaceSymbol::PutBoundarySymbol ( struct ICurveSymbol * pVal ) {
    HRESULT _hr = put_BoundarySymbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(289)
inline VARIANT_BOOL ISurfaceSymbol::GetEnableLight ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableLight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(290)
inline void ISurfaceSymbol::PutEnableLight ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableLight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(291)
inline _bstr_t ISurfaceSymbol::GetImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(292)
inline void ISurfaceSymbol::PutImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_ImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(293)
inline float ISurfaceSymbol::GetRepeatLengthU ( ) {
    float _result = 0;
    HRESULT _hr = get_RepeatLengthU(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(294)
inline void ISurfaceSymbol::PutRepeatLengthU ( float pVal ) {
    HRESULT _hr = put_RepeatLengthU(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(295)
inline float ISurfaceSymbol::GetRepeatLengthV ( ) {
    float _result = 0;
    HRESULT _hr = get_RepeatLengthV(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(296)
inline void ISurfaceSymbol::PutRepeatLengthV ( float pVal ) {
    HRESULT _hr = put_RepeatLengthV(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(297)
inline float ISurfaceSymbol::GetRotation ( ) {
    float _result = 0;
    HRESULT _hr = get_Rotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(298)
inline void ISurfaceSymbol::PutRotation ( float pVal ) {
    HRESULT _hr = put_Rotation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderPolygon wrapper method implementations
//

#pragma implementation_key(299)
inline ISurfaceSymbolPtr IRenderPolygon::GetSymbol ( ) {
    struct ISurfaceSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurfaceSymbolPtr(_result, false);
}

#pragma implementation_key(300)
inline void IRenderPolygon::PutSymbol ( struct ISurfaceSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(301)
inline enum gviHeightStyle IRenderPolygon::GetHeightStyle ( ) {
    enum gviHeightStyle _result;
    HRESULT _hr = get_HeightStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(302)
inline void IRenderPolygon::PutHeightStyle ( enum gviHeightStyle pVal ) {
    HRESULT _hr = put_HeightStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderTriMesh wrapper method implementations
//

#pragma implementation_key(303)
inline ISurfaceSymbolPtr IRenderTriMesh::GetSymbol ( ) {
    struct ISurfaceSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurfaceSymbolPtr(_result, false);
}

#pragma implementation_key(304)
inline void IRenderTriMesh::PutSymbol ( struct ISurfaceSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderMultiTriMesh wrapper method implementations
//

#pragma implementation_key(305)
inline ISurfaceSymbolPtr IRenderMultiTriMesh::GetSymbol ( ) {
    struct ISurfaceSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurfaceSymbolPtr(_result, false);
}

#pragma implementation_key(306)
inline void IRenderMultiTriMesh::PutSymbol ( struct ISurfaceSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPointSymbol wrapper method implementations
//

#pragma implementation_key(307)
inline long IPointSymbol::GetSize ( ) {
    long _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(308)
inline void IPointSymbol::PutSize ( long pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(309)
inline enum gviPivotAlignment IPointSymbol::GetAlignment ( ) {
    enum gviPivotAlignment _result;
    HRESULT _hr = get_Alignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(310)
inline void IPointSymbol::PutAlignment ( enum gviPivotAlignment pVal ) {
    HRESULT _hr = put_Alignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderMultiPoint wrapper method implementations
//

#pragma implementation_key(311)
inline IPointSymbolPtr IRenderMultiPoint::GetSymbol ( ) {
    struct IPointSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointSymbolPtr(_result, false);
}

#pragma implementation_key(312)
inline void IRenderMultiPoint::PutSymbol ( struct IPointSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ICameraTour wrapper method implementations
//

#pragma implementation_key(313)
inline HRESULT ICameraTour::ClearWaypoints ( ) {
    HRESULT _hr = raw_ClearWaypoints();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(314)
inline HRESULT ICameraTour::AddWaypoint ( struct IVector3 * Position, struct IEulerAngle * Angle, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_AddWaypoint(Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(315)
inline HRESULT ICameraTour::AddWaypoint2 ( struct IPoint * Position, struct IEulerAngle * Angle, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_AddWaypoint2(Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(316)
inline HRESULT ICameraTour::ModifyWaypoint ( long Index, struct IVector3 * Position, struct IEulerAngle * Angle, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_ModifyWaypoint(Index, Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(317)
inline HRESULT ICameraTour::ModifyWaypoint2 ( long Index, struct IPoint * Position, struct IEulerAngle * Angle, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_ModifyWaypoint2(Index, Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(318)
inline HRESULT ICameraTour::InsertWaypoint ( long Index, struct IVector3 * Position, struct IEulerAngle * Angle, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_InsertWaypoint(Index, Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(319)
inline HRESULT ICameraTour::InsertWaypoint2 ( long Index, struct IPoint * Position, struct IEulerAngle * Angle, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_InsertWaypoint2(Index, Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(320)
inline HRESULT ICameraTour::GetWaypoint ( long Index, struct IVector3 * * Position, struct IEulerAngle * * Angle, double * Duration, enum gviCameraTourMode * Mode ) {
    HRESULT _hr = raw_GetWaypoint(Index, Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(321)
inline HRESULT ICameraTour::GetWaypoint2 ( long Index, struct IPoint * * Position, struct IEulerAngle * * Angle, double * Duration, enum gviCameraTourMode * Mode ) {
    HRESULT _hr = raw_GetWaypoint2(Index, Position, Angle, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(322)
inline HRESULT ICameraTour::DeleteWaypoint ( long Index ) {
    HRESULT _hr = raw_DeleteWaypoint(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(323)
inline HRESULT ICameraTour::Play ( ) {
    HRESULT _hr = raw_Play();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(324)
inline HRESULT ICameraTour::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(325)
inline HRESULT ICameraTour::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(326)
inline double ICameraTour::GetTotalTime ( ) {
    double _result = 0;
    HRESULT _hr = get_TotalTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(327)
inline double ICameraTour::GetTime ( ) {
    double _result = 0;
    HRESULT _hr = get_Time(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(328)
inline void ICameraTour::PutTime ( double pVal ) {
    HRESULT _hr = put_Time(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(329)
inline VARIANT_BOOL ICameraTour::GetAutoRepeat ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoRepeat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(330)
inline void ICameraTour::PutAutoRepeat ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoRepeat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(331)
inline long ICameraTour::GetWaypointsNumber ( ) {
    long _result = 0;
    HRESULT _hr = get_WaypointsNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(332)
inline long ICameraTour::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(333)
inline void ICameraTour::PutIndex ( long pVal ) {
    HRESULT _hr = put_Index(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(334)
inline _bstr_t ICameraTour::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(335)
inline VARIANT_BOOL ICameraTour::FromXml ( _bstr_t XmlStringValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FromXml(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(336)
inline VARIANT_BOOL ICameraTour::ExportVideo ( _bstr_t FilePath, long FPS ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportVideo(FilePath, FPS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(337)
inline HRESULT ICameraTour::CancelExport ( ) {
    HRESULT _hr = raw_CancelExport();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(338)
inline VARIANT_BOOL ICameraTour::GetIsExporting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsExporting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(339)
inline HRESULT ICameraTour::FromAse ( _bstr_t File ) {
    HRESULT _hr = raw_FromAse(File);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(340)
inline HRESULT ICameraTour::AddWaypointByMatrix ( struct IMatrix * Mat, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_AddWaypointByMatrix(Mat, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(341)
inline HRESULT ICameraTour::GetWaypointByMatrix ( long Index, struct IMatrix * * Mat, double * Duration, enum gviCameraTourMode * Mode ) {
    HRESULT _hr = raw_GetWaypointByMatrix(Index, Mat, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(342)
inline HRESULT ICameraTour::ModifyWaypointByMatrix ( long Index, struct IMatrix * Mat, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_ModifyWaypointByMatrix(Index, Mat, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(343)
inline HRESULT ICameraTour::InsertWaypointByMatrix ( long Index, struct IMatrix * Mat, double Duration, enum gviCameraTourMode Mode ) {
    HRESULT _hr = raw_InsertWaypointByMatrix(Index, Mat, Duration, Mode);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(344)
inline VARIANT_BOOL ICameraTour::ExportFrameSequence ( _bstr_t FilePath, long Width, long Height, long FPS ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportFrameSequence(FilePath, Width, Height, FPS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(345)
inline _bstr_t ICameraTour::GetCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(346)
inline void ICameraTour::PutCrsWKT ( _bstr_t pVal ) {
    HRESULT _hr = put_CrsWKT(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(347)
inline VARIANT_BOOL ICameraTour::ExportPanoramaFrameSequence ( _bstr_t FilePath, long Width, long FPS ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportPanoramaFrameSequence(FilePath, Width, FPS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(348)
inline _bstr_t ICameraTour::GetSlideImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SlideImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(349)
inline void ICameraTour::PutSlideImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_SlideImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderPoint wrapper method implementations
//

#pragma implementation_key(350)
inline IPointSymbolPtr IRenderPoint::GetSymbol ( ) {
    struct IPointSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointSymbolPtr(_result, false);
}

#pragma implementation_key(351)
inline void IRenderPoint::PutSymbol ( struct IPointSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IMotionPath wrapper method implementations
//

#pragma implementation_key(352)
inline HRESULT IMotionPath::AddWaypoint ( struct IVector3 * Position, struct IEulerAngle * Angle, struct IVector3 * Scale, double When ) {
    HRESULT _hr = raw_AddWaypoint(Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(353)
inline HRESULT IMotionPath::AddWaypoint2 ( struct IPoint * Position, struct IEulerAngle * Angle, struct IVector3 * Scale, double When ) {
    HRESULT _hr = raw_AddWaypoint2(Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(354)
inline HRESULT IMotionPath::ModifyWaypoint ( long Index, struct IVector3 * Position, struct IEulerAngle * Angle, struct IVector3 * Scale, double When ) {
    HRESULT _hr = raw_ModifyWaypoint(Index, Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(355)
inline HRESULT IMotionPath::ModifyWaypoint2 ( long Index, struct IPoint * Position, struct IEulerAngle * Angle, struct IVector3 * Scale, double When ) {
    HRESULT _hr = raw_ModifyWaypoint2(Index, Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(356)
inline HRESULT IMotionPath::InsertWaypoint ( long Index, struct IVector3 * Position, struct IEulerAngle * Angle, struct IVector3 * Scale, double When ) {
    HRESULT _hr = raw_InsertWaypoint(Index, Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(357)
inline HRESULT IMotionPath::InsertWaypoint2 ( long Index, struct IPoint * Position, struct IEulerAngle * Angle, struct IVector3 * Scale, double When ) {
    HRESULT _hr = raw_InsertWaypoint2(Index, Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(358)
inline HRESULT IMotionPath::GetWaypoint ( long Index, struct IVector3 * * Position, struct IEulerAngle * * Angle, struct IVector3 * * Scale, double * When ) {
    HRESULT _hr = raw_GetWaypoint(Index, Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(359)
inline HRESULT IMotionPath::GetWaypoint2 ( long Index, struct IPoint * * Position, struct IEulerAngle * * Angle, struct IVector3 * * Scale, double * When ) {
    HRESULT _hr = raw_GetWaypoint2(Index, Position, Angle, Scale, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(360)
inline HRESULT IMotionPath::DeleteWaypoint ( long Index ) {
    HRESULT _hr = raw_DeleteWaypoint(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(361)
inline HRESULT IMotionPath::ClearWaypoints ( ) {
    HRESULT _hr = raw_ClearWaypoints();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(362)
inline HRESULT IMotionPath::Play ( ) {
    HRESULT _hr = raw_Play();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(363)
inline HRESULT IMotionPath::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(364)
inline HRESULT IMotionPath::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(365)
inline double IMotionPath::GetTime ( ) {
    double _result = 0;
    HRESULT _hr = get_Time(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(366)
inline void IMotionPath::PutTime ( double pVal ) {
    HRESULT _hr = put_Time(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(367)
inline VARIANT_BOOL IMotionPath::GetAutoRepeat ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoRepeat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(368)
inline void IMotionPath::PutAutoRepeat ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoRepeat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(369)
inline long IMotionPath::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(370)
inline void IMotionPath::PutIndex ( long pVal ) {
    HRESULT _hr = put_Index(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(371)
inline _bstr_t IMotionPath::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(372)
inline VARIANT_BOOL IMotionPath::FromXml ( _bstr_t XmlStringValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FromXml(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(373)
inline double IMotionPath::GetTotalDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_TotalDuration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(374)
inline HRESULT IMotionPath::AddWaypointByMatrix ( struct IMatrix * Mat, double When ) {
    HRESULT _hr = raw_AddWaypointByMatrix(Mat, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(375)
inline HRESULT IMotionPath::GetWaypointByMatrix ( long Index, struct IMatrix * * Mat, double * When ) {
    HRESULT _hr = raw_GetWaypointByMatrix(Index, Mat, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(376)
inline HRESULT IMotionPath::ModifyWaypointByMatrix ( long Index, struct IMatrix * Mat, double When ) {
    HRESULT _hr = raw_ModifyWaypointByMatrix(Index, Mat, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(377)
inline HRESULT IMotionPath::InsertWaypointByMatrix ( long Index, struct IMatrix * Mat, double When ) {
    HRESULT _hr = raw_InsertWaypointByMatrix(Index, Mat, When);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(378)
inline long IMotionPath::GetWaypointsNumber ( ) {
    long _result = 0;
    HRESULT _hr = get_WaypointsNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(379)
inline _bstr_t IMotionPath::GetCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(380)
inline void IMotionPath::PutCrsWKT ( _bstr_t pVal ) {
    HRESULT _hr = put_CrsWKT(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IParticleEffect wrapper method implementations
//

#pragma implementation_key(381)
inline VARIANT_BOOL IParticleEffect::Start ( double Duration ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Start(Duration, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(382)
inline HRESULT IParticleEffect::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(383)
inline HRESULT IParticleEffect::SetPointEmitter ( struct IPoint * Position ) {
    HRESULT _hr = raw_SetPointEmitter(Position);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(384)
inline HRESULT IParticleEffect::GetPointEmitter ( struct IPoint * * Position ) {
    HRESULT _hr = raw_GetPointEmitter(Position);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(385)
inline HRESULT IParticleEffect::SetBoxEmitter ( struct IPoint * Position, double Width, double Height, double Depth ) {
    HRESULT _hr = raw_SetBoxEmitter(Position, Width, Height, Depth);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(386)
inline HRESULT IParticleEffect::GetBoxEmitter ( struct IPoint * * Position, double * Width, double * Height, double * Depth ) {
    HRESULT _hr = raw_GetBoxEmitter(Position, Width, Height, Depth);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(387)
inline HRESULT IParticleEffect::SetCircleEmitter ( struct IPoint * Position, double Radius ) {
    HRESULT _hr = raw_SetCircleEmitter(Position, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(388)
inline HRESULT IParticleEffect::GetCircleEmitter ( struct IPoint * * Position, double * Radius ) {
    HRESULT _hr = raw_GetCircleEmitter(Position, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(389)
inline HRESULT IParticleEffect::SetTextureTileRange ( long HTile, long VTile, long StartTile, long EndTile ) {
    HRESULT _hr = raw_SetTextureTileRange(HTile, VTile, StartTile, EndTile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(390)
inline HRESULT IParticleEffect::GetTextureTileRange ( long * HTile, long * VTile, long * StartTile, long * EndTile ) {
    HRESULT _hr = raw_GetTextureTileRange(HTile, VTile, StartTile, EndTile);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(391)
inline _bstr_t IParticleEffect::GetImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(392)
inline void IParticleEffect::PutImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_ImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(393)
inline double IParticleEffect::GetEmissionMinMoveSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMinMoveSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(394)
inline void IParticleEffect::PutEmissionMinMoveSpeed ( double pVal ) {
    HRESULT _hr = put_EmissionMinMoveSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(395)
inline double IParticleEffect::GetEmissionMaxMoveSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMaxMoveSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(396)
inline void IParticleEffect::PutEmissionMaxMoveSpeed ( double pVal ) {
    HRESULT _hr = put_EmissionMaxMoveSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(397)
inline double IParticleEffect::GetEmissionMinRotationSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMinRotationSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(398)
inline void IParticleEffect::PutEmissionMinRotationSpeed ( double pVal ) {
    HRESULT _hr = put_EmissionMinRotationSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(399)
inline double IParticleEffect::GetEmissionMaxRotationSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMaxRotationSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(400)
inline void IParticleEffect::PutEmissionMaxRotationSpeed ( double pVal ) {
    HRESULT _hr = put_EmissionMaxRotationSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(401)
inline double IParticleEffect::GetEmissionMinScaleSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMinScaleSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(402)
inline void IParticleEffect::PutEmissionMinScaleSpeed ( double pVal ) {
    HRESULT _hr = put_EmissionMinScaleSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(403)
inline double IParticleEffect::GetEmissionMaxScaleSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMaxScaleSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(404)
inline void IParticleEffect::PutEmissionMaxScaleSpeed ( double pVal ) {
    HRESULT _hr = put_EmissionMaxScaleSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(405)
inline double IParticleEffect::GetEmissionMinAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMinAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(406)
inline void IParticleEffect::PutEmissionMinAngle ( double pVal ) {
    HRESULT _hr = put_EmissionMinAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(407)
inline double IParticleEffect::GetEmissionMaxAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMaxAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(408)
inline void IParticleEffect::PutEmissionMaxAngle ( double pVal ) {
    HRESULT _hr = put_EmissionMaxAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(409)
inline double IParticleEffect::GetEmissionMinRate ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMinRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(410)
inline void IParticleEffect::PutEmissionMinRate ( double pVal ) {
    HRESULT _hr = put_EmissionMinRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(411)
inline double IParticleEffect::GetEmissionMaxRate ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMaxRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(412)
inline void IParticleEffect::PutEmissionMaxRate ( double pVal ) {
    HRESULT _hr = put_EmissionMaxRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(413)
inline double IParticleEffect::GetEmissionMinParticleSize ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMinParticleSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(414)
inline void IParticleEffect::PutEmissionMinParticleSize ( double pVal ) {
    HRESULT _hr = put_EmissionMinParticleSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(415)
inline double IParticleEffect::GetEmissionMaxParticleSize ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionMaxParticleSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(416)
inline void IParticleEffect::PutEmissionMaxParticleSize ( double pVal ) {
    HRESULT _hr = put_EmissionMaxParticleSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(417)
inline double IParticleEffect::GetParticleAspectRatio ( ) {
    double _result = 0;
    HRESULT _hr = get_ParticleAspectRatio(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(418)
inline void IParticleEffect::PutParticleAspectRatio ( double pVal ) {
    HRESULT _hr = put_ParticleAspectRatio(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(419)
inline double IParticleEffect::GetParticleMinLifeTime ( ) {
    double _result = 0;
    HRESULT _hr = get_ParticleMinLifeTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(420)
inline void IParticleEffect::PutParticleMinLifeTime ( double pVal ) {
    HRESULT _hr = put_ParticleMinLifeTime(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(421)
inline double IParticleEffect::GetParticleMaxLifeTime ( ) {
    double _result = 0;
    HRESULT _hr = get_ParticleMaxLifeTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(422)
inline void IParticleEffect::PutParticleMaxLifeTime ( double pVal ) {
    HRESULT _hr = put_ParticleMaxLifeTime(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(423)
inline OLE_COLOR IParticleEffect::GetParticleBirthColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ParticleBirthColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(424)
inline void IParticleEffect::PutParticleBirthColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_ParticleBirthColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(425)
inline OLE_COLOR IParticleEffect::GetParticleDeathColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ParticleDeathColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(426)
inline void IParticleEffect::PutParticleDeathColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_ParticleDeathColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(427)
inline double IParticleEffect::GetWindDirection ( ) {
    double _result = 0;
    HRESULT _hr = get_WindDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(428)
inline void IParticleEffect::PutWindDirection ( double pVal ) {
    HRESULT _hr = put_WindDirection(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(429)
inline double IParticleEffect::GetWindAcceleration ( ) {
    double _result = 0;
    HRESULT _hr = get_WindAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(430)
inline void IParticleEffect::PutWindAcceleration ( double pVal ) {
    HRESULT _hr = put_WindAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(431)
inline double IParticleEffect::GetDamping ( ) {
    double _result = 0;
    HRESULT _hr = get_Damping(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(432)
inline void IParticleEffect::PutDamping ( double pVal ) {
    HRESULT _hr = put_Damping(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(433)
inline enum gviParticleBillboardType IParticleEffect::GetParticleBillboardType ( ) {
    enum gviParticleBillboardType _result;
    HRESULT _hr = get_ParticleBillboardType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(434)
inline void IParticleEffect::PutParticleBillboardType ( enum gviParticleBillboardType pVal ) {
    HRESULT _hr = put_ParticleBillboardType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(435)
inline double IParticleEffect::GetVerticalAcceleration ( ) {
    double _result = 0;
    HRESULT _hr = get_VerticalAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(436)
inline void IParticleEffect::PutVerticalAcceleration ( double pVal ) {
    HRESULT _hr = put_VerticalAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(437)
inline IEulerAnglePtr IParticleEffect::GetEmissionDirectionEulerAngle ( ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = get_EmissionDirectionEulerAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(438)
inline void IParticleEffect::PutEmissionDirectionEulerAngle ( struct IEulerAngle * pVal ) {
    HRESULT _hr = put_EmissionDirectionEulerAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(439)
inline IPointPtr IParticleEffect::GetPosition ( ) {
    struct IPoint * _result = 0;
    HRESULT _hr = raw_GetPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(440)
inline enum gviEmitterType IParticleEffect::GetEmitterType ( ) {
    enum gviEmitterType _result;
    HRESULT _hr = get_EmitterType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITextAttribute wrapper method implementations
//

#pragma implementation_key(441)
inline long ITextAttribute::GetTextSize ( ) {
    long _result = 0;
    HRESULT _hr = get_TextSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(442)
inline void ITextAttribute::PutTextSize ( long pVal ) {
    HRESULT _hr = put_TextSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(443)
inline VARIANT_BOOL ITextAttribute::GetItalic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Italic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(444)
inline void ITextAttribute::PutItalic ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Italic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(445)
inline VARIANT_BOOL ITextAttribute::GetBold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Bold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(446)
inline void ITextAttribute::PutBold ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Bold(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(447)
inline VARIANT_BOOL ITextAttribute::GetUnderline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Underline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(448)
inline void ITextAttribute::PutUnderline ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Underline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(449)
inline OLE_COLOR ITextAttribute::GetTextColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TextColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(450)
inline void ITextAttribute::PutTextColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_TextColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(451)
inline OLE_COLOR ITextAttribute::GetOutlineColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_OutlineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(452)
inline void ITextAttribute::PutOutlineColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_OutlineColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(453)
inline _bstr_t ITextAttribute::GetFont ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Font(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(454)
inline void ITextAttribute::PutFont ( _bstr_t pVal ) {
    HRESULT _hr = put_Font(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(455)
inline OLE_COLOR ITextAttribute::GetBackgroundColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackgroundColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(456)
inline void ITextAttribute::PutBackgroundColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackgroundColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(457)
inline enum gviMultilineJustification ITextAttribute::GetMultilineJustification ( ) {
    enum gviMultilineJustification _result;
    HRESULT _hr = get_MultilineJustification(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(458)
inline void ITextAttribute::PutMultilineJustification ( enum gviMultilineJustification pVal ) {
    HRESULT _hr = put_MultilineJustification(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITextSymbol wrapper method implementations
//

#pragma implementation_key(459)
inline ITextAttributePtr ITextSymbol::GetTextAttribute ( ) {
    struct ITextAttribute * _result = 0;
    HRESULT _hr = get_TextAttribute(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextAttributePtr(_result, false);
}

#pragma implementation_key(460)
inline void ITextSymbol::PutTextAttribute ( struct ITextAttribute * pVal ) {
    HRESULT _hr = put_TextAttribute(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(461)
inline double ITextSymbol::GetVerticalOffset ( ) {
    double _result = 0;
    HRESULT _hr = get_VerticalOffset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(462)
inline void ITextSymbol::PutVerticalOffset ( double pVal ) {
    HRESULT _hr = put_VerticalOffset(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(463)
inline VARIANT_BOOL ITextSymbol::GetDrawLine ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DrawLine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(464)
inline void ITextSymbol::PutDrawLine ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DrawLine(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(465)
inline OLE_COLOR ITextSymbol::GetLineColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_LineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(466)
inline void ITextSymbol::PutLineColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_LineColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(467)
inline double ITextSymbol::GetMinVisualDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_MinVisualDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(468)
inline void ITextSymbol::PutMinVisualDistance ( double pVal ) {
    HRESULT _hr = put_MinVisualDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(469)
inline double ITextSymbol::GetMaxVisualDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxVisualDistance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(470)
inline void ITextSymbol::PutMaxVisualDistance ( double pVal ) {
    HRESULT _hr = put_MaxVisualDistance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(471)
inline long ITextSymbol::GetPriority ( ) {
    long _result = 0;
    HRESULT _hr = get_Priority(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(472)
inline void ITextSymbol::PutPriority ( long pVal ) {
    HRESULT _hr = put_Priority(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(473)
inline enum gviPivotAlignment ITextSymbol::GetPivotAlignment ( ) {
    enum gviPivotAlignment _result;
    HRESULT _hr = get_PivotAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(474)
inline void ITextSymbol::PutPivotAlignment ( enum gviPivotAlignment pVal ) {
    HRESULT _hr = put_PivotAlignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(475)
inline long ITextSymbol::GetMarginWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_MarginWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(476)
inline void ITextSymbol::PutMarginWidth ( long pVal ) {
    HRESULT _hr = put_MarginWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(477)
inline long ITextSymbol::GetMarginHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_MarginHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(478)
inline void ITextSymbol::PutMarginHeight ( long pVal ) {
    HRESULT _hr = put_MarginHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(479)
inline enum gviLockMode ITextSymbol::GetLockMode ( ) {
    enum gviLockMode _result;
    HRESULT _hr = get_LockMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(480)
inline void ITextSymbol::PutLockMode ( enum gviLockMode pVal ) {
    HRESULT _hr = put_LockMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(481)
inline OLE_COLOR ITextSymbol::GetMarginColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_MarginColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(482)
inline void ITextSymbol::PutMarginColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_MarginColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(483)
inline _bstr_t ITextSymbol::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface ILabel wrapper method implementations
//

#pragma implementation_key(484)
inline _bstr_t ILabel::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(485)
inline void ILabel::PutText ( _bstr_t pVal ) {
    HRESULT _hr = put_Text(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(486)
inline IPointPtr ILabel::GetPosition ( ) {
    struct IPoint * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(487)
inline void ILabel::PutPosition ( struct IPoint * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(488)
inline ITextSymbolPtr ILabel::GetTextSymbol ( ) {
    struct ITextSymbol * _result = 0;
    HRESULT _hr = get_TextSymbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextSymbolPtr(_result, false);
}

#pragma implementation_key(489)
inline void ILabel::PutTextSymbol ( struct ITextSymbol * pVal ) {
    HRESULT _hr = put_TextSymbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITableLabel wrapper method implementations
//

#pragma implementation_key(490)
inline OLE_COLOR ITableLabel::GetBorderColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BorderColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(491)
inline void ITableLabel::PutBorderColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BorderColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(492)
inline float ITableLabel::GetBorderWidth ( ) {
    float _result = 0;
    HRESULT _hr = get_BorderWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(493)
inline void ITableLabel::PutBorderWidth ( float pVal ) {
    HRESULT _hr = put_BorderWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(494)
inline _bstr_t ITableLabel::GetTitleText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TitleText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(495)
inline void ITableLabel::PutTitleText ( _bstr_t pVal ) {
    HRESULT _hr = put_TitleText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(496)
inline OLE_COLOR ITableLabel::GetTitleBackgroundColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TitleBackgroundColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(497)
inline void ITableLabel::PutTitleBackgroundColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_TitleBackgroundColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(498)
inline ITextAttributePtr ITableLabel::GetTitleTextAttribute ( ) {
    struct ITextAttribute * _result = 0;
    HRESULT _hr = get_TitleTextAttribute(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextAttributePtr(_result, false);
}

#pragma implementation_key(499)
inline void ITableLabel::PutTitleTextAttribute ( struct ITextAttribute * pVal ) {
    HRESULT _hr = put_TitleTextAttribute(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(500)
inline OLE_COLOR ITableLabel::GetTableBackgroundColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TableBackgroundColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(501)
inline void ITableLabel::PutTableBackgroundColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_TableBackgroundColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(502)
inline ITextAttributePtr ITableLabel::GetColumnTextAttribute ( long Index ) {
    struct ITextAttribute * _result = 0;
    HRESULT _hr = raw_GetColumnTextAttribute(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextAttributePtr(_result, false);
}

#pragma implementation_key(503)
inline HRESULT ITableLabel::SetColumnTextAttribute ( long Index, struct ITextAttribute * newVal ) {
    HRESULT _hr = raw_SetColumnTextAttribute(Index, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(504)
inline HRESULT ITableLabel::SetColumnWidth ( long Index, long Width ) {
    HRESULT _hr = raw_SetColumnWidth(Index, Width);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(505)
inline long ITableLabel::GetColumnWidth ( long Index ) {
    long _result = 0;
    HRESULT _hr = raw_GetColumnWidth(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(506)
inline HRESULT ITableLabel::SetRecord ( long Row, long Col, _bstr_t Record ) {
    HRESULT _hr = raw_SetRecord(Row, Col, Record);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(507)
inline _bstr_t ITableLabel::GetRecord ( long Row, long Col ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetRecord(Row, Col, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(508)
inline IPointPtr ITableLabel::GetPosition ( ) {
    struct IPoint * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(509)
inline void ITableLabel::PutPosition ( struct IPoint * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(510)
inline long ITableLabel::GetRowCount ( ) {
    long _result = 0;
    HRESULT _hr = get_RowCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(511)
inline long ITableLabel::GetColumnCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ColumnCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(512)
inline _bstr_t ITableLabel::GetBackgroundImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_BackgroundImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(513)
inline void ITableLabel::PutBackgroundImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_BackgroundImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISkinnedMesh wrapper method implementations
//

#pragma implementation_key(514)
inline VARIANT_BOOL ISkinnedMesh::GetLoop ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Loop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(515)
inline void ISkinnedMesh::PutLoop ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Loop(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(516)
inline double ISkinnedMesh::GetDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_Duration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(517)
inline void ISkinnedMesh::PutDuration ( double pVal ) {
    HRESULT _hr = put_Duration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(518)
inline HRESULT ISkinnedMesh::Play ( ) {
    HRESULT _hr = raw_Play();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(519)
inline HRESULT ISkinnedMesh::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(520)
inline HRESULT ISkinnedMesh::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(521)
inline IModelPointPtr ISkinnedMesh::GetModelPoint ( ) {
    struct IModelPoint * _result = 0;
    HRESULT _hr = get_ModelPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IModelPointPtr(_result, false);
}

#pragma implementation_key(522)
inline void ISkinnedMesh::PutModelPoint ( struct IModelPoint * pVal ) {
    HRESULT _hr = put_ModelPoint(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(523)
inline unsigned long ISkinnedMesh::GetAnimationCount ( ) {
    unsigned long _result = 0;
    HRESULT _hr = get_AnimationCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(524)
inline unsigned long ISkinnedMesh::GetAnimationIndex ( ) {
    unsigned long _result = 0;
    HRESULT _hr = get_AnimationIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(525)
inline void ISkinnedMesh::PutAnimationIndex ( unsigned long pVal ) {
    HRESULT _hr = put_AnimationIndex(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(526)
inline VARIANT_BOOL ISkinnedMesh::ClampAnimation ( double StartPercentage, double EndPercentage ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ClampAnimation(StartPercentage, EndPercentage, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IRenderMultiPolyline wrapper method implementations
//

#pragma implementation_key(527)
inline ICurveSymbolPtr IRenderMultiPolyline::GetSymbol ( ) {
    struct ICurveSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICurveSymbolPtr(_result, false);
}

#pragma implementation_key(528)
inline void IRenderMultiPolyline::PutSymbol ( struct ICurveSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(529)
inline enum gviHeightStyle IRenderMultiPolyline::GetHeightStyle ( ) {
    enum gviHeightStyle _result;
    HRESULT _hr = get_HeightStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(530)
inline void IRenderMultiPolyline::PutHeightStyle ( enum gviHeightStyle pVal ) {
    HRESULT _hr = put_HeightStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderMultiPolygon wrapper method implementations
//

#pragma implementation_key(531)
inline ISurfaceSymbolPtr IRenderMultiPolygon::GetSymbol ( ) {
    struct ISurfaceSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurfaceSymbolPtr(_result, false);
}

#pragma implementation_key(532)
inline void IRenderMultiPolygon::PutSymbol ( struct ISurfaceSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(533)
inline enum gviHeightStyle IRenderMultiPolygon::GetHeightStyle ( ) {
    enum gviHeightStyle _result;
    HRESULT _hr = get_HeightStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(534)
inline void IRenderMultiPolygon::PutHeightStyle ( enum gviHeightStyle pVal ) {
    HRESULT _hr = put_HeightStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IProjectTree wrapper method implementations
//

#pragma implementation_key(535)
inline GUID IProjectTree::GetNotInTreeID ( ) {
    GUID _result;
    HRESULT _hr = get_NotInTreeID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(536)
inline GUID IProjectTree::GetRootID ( ) {
    GUID _result;
    HRESULT _hr = get_RootID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(537)
inline GUID IProjectTree::CreateGroup ( _bstr_t GroupName, GUID ParentGroupID ) {
    GUID _result;
    HRESULT _hr = raw_CreateGroup(GroupName, ParentGroupID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(538)
inline GUID IProjectTree::CreateLockedGroup ( _bstr_t GroupName, GUID ParentGroupID ) {
    GUID _result;
    HRESULT _hr = raw_CreateLockedGroup(GroupName, ParentGroupID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(539)
inline HRESULT IProjectTree::DeleteItem ( GUID Id ) {
    HRESULT _hr = raw_DeleteItem(Id);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(540)
inline GUID IProjectTree::FindItem ( _bstr_t Path ) {
    GUID _result;
    HRESULT _hr = raw_FindItem(Path, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(541)
inline _bstr_t IProjectTree::GetItemName ( GUID Id ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetItemName(Id, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(542)
inline GUID IProjectTree::GetNextItem ( GUID Id, long Code ) {
    GUID _result;
    HRESULT _hr = raw_GetNextItem(Id, Code, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(543)
inline long IProjectTree::GetVisibility ( GUID Id ) {
    long _result = 0;
    HRESULT _hr = raw_GetVisibility(Id, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(544)
inline VARIANT_BOOL IProjectTree::IsGroup ( GUID Id ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsGroup(Id, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(545)
inline VARIANT_BOOL IProjectTree::IsLocked ( GUID Id ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsLocked(Id, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(546)
inline GUID IProjectTree::LoadCepLayer ( _bstr_t CepURL, GUID ParentGroupID ) {
    GUID _result;
    HRESULT _hr = raw_LoadCepLayer(CepURL, ParentGroupID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(547)
inline HRESULT IProjectTree::LockGroup ( GUID GroupId, VARIANT_BOOL Lock ) {
    HRESULT _hr = raw_LockGroup(GroupId, Lock);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(548)
inline HRESULT IProjectTree::RenameGroup ( GUID GroupId, _bstr_t GroupName ) {
    HRESULT _hr = raw_RenameGroup(GroupId, GroupName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(549)
inline _bstr_t IProjectTree::SaveAsCep ( _bstr_t CepName, GUID GroupId ) {
    BSTR _result = 0;
    HRESULT _hr = raw_SaveAsCep(CepName, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(550)
inline HRESULT IProjectTree::SetParent ( GUID Id, GUID GroupId, long Index ) {
    HRESULT _hr = raw_SetParent(Id, GroupId, Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(551)
inline HRESULT IProjectTree::SetVisibility ( GUID Id, unsigned char VisibleMask ) {
    HRESULT _hr = raw_SetVisibility(Id, VisibleMask);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(552)
inline HRESULT IProjectTree::SetClientData ( GUID Id, _bstr_t Name, _bstr_t Value ) {
    HRESULT _hr = raw_SetClientData(Id, Name, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(553)
inline _bstr_t IProjectTree::GetClientData ( GUID Id, _bstr_t Name ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetClientData(Id, Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(554)
inline VARIANT_BOOL IProjectTree::GetShowSlide ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowSlide(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(555)
inline void IProjectTree::PutShowSlide ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowSlide(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(556)
inline HRESULT IProjectTree::SetGroupSlideImageName ( GUID GroupId, _bstr_t ImageName ) {
    HRESULT _hr = raw_SetGroupSlideImageName(GroupId, ImageName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(557)
inline _bstr_t IProjectTree::GetGroupSlideImageName ( GUID GroupId ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetGroupSlideImageName(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(558)
inline GUID IProjectTree::GetSlideRootGroup ( ) {
    GUID _result;
    HRESULT _hr = get_SlideRootGroup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(559)
inline void IProjectTree::PutSlideRootGroup ( GUID pVal ) {
    HRESULT _hr = put_SlideRootGroup(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRasterSymbol wrapper method implementations
//

#pragma implementation_key(560)
inline long IRasterSymbol::GetRedBand ( ) {
    long _result = 0;
    HRESULT _hr = get_RedBand(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(561)
inline void IRasterSymbol::PutRedBand ( long pVal ) {
    HRESULT _hr = put_RedBand(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(562)
inline long IRasterSymbol::GetGreenBand ( ) {
    long _result = 0;
    HRESULT _hr = get_GreenBand(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(563)
inline void IRasterSymbol::PutGreenBand ( long pVal ) {
    HRESULT _hr = put_GreenBand(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(564)
inline long IRasterSymbol::GetBlueBand ( ) {
    long _result = 0;
    HRESULT _hr = get_BlueBand(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(565)
inline void IRasterSymbol::PutBlueBand ( long pVal ) {
    HRESULT _hr = put_BlueBand(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(566)
inline long IRasterSymbol::GetAlphaBand ( ) {
    long _result = 0;
    HRESULT _hr = get_AlphaBand(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(567)
inline void IRasterSymbol::PutAlphaBand ( long pVal ) {
    HRESULT _hr = put_AlphaBand(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(568)
inline VARIANT_BOOL IRasterSymbol::GetRedEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_RedEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(569)
inline void IRasterSymbol::PutRedEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_RedEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(570)
inline VARIANT_BOOL IRasterSymbol::GetGreenEnable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_GreenEnable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(571)
inline void IRasterSymbol::PutGreenEnable ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_GreenEnable(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(572)
inline VARIANT_BOOL IRasterSymbol::GetBlueEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BlueEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(573)
inline void IRasterSymbol::PutBlueEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BlueEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(574)
inline VARIANT_BOOL IRasterSymbol::GetAlphaEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AlphaEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(575)
inline void IRasterSymbol::PutAlphaEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AlphaEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(576)
inline VARIANT_BOOL IRasterSymbol::GetBackgroundEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BackgroundEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(577)
inline void IRasterSymbol::PutBackgroundEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_BackgroundEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(578)
inline OLE_COLOR IRasterSymbol::GetBackgroundKey ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackgroundKey(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(579)
inline void IRasterSymbol::PutBackgroundKey ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackgroundKey(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(580)
inline OLE_COLOR IRasterSymbol::GetBackgroundValue ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackgroundValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(581)
inline void IRasterSymbol::PutBackgroundValue ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackgroundValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IImageryLayer wrapper method implementations
//

#pragma implementation_key(582)
inline long IImageryLayer::GetImageWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_ImageWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(583)
inline long IImageryLayer::GetImageHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_ImageHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(584)
inline _bstr_t IImageryLayer::GetWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(585)
inline VARIANT_BOOL IImageryLayer::SetWKT ( _bstr_t newVal ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetWKT(newVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(586)
inline _bstr_t IImageryLayer::GetConnectionString ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConnectionString(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(587)
inline IRasterSymbolPtr IImageryLayer::GetRasterSymbol ( ) {
    struct IRasterSymbol * _result = 0;
    HRESULT _hr = raw_GetRasterSymbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRasterSymbolPtr(_result, false);
}

#pragma implementation_key(588)
inline HRESULT IImageryLayer::SetRasterSymbol ( struct IRasterSymbol * newVal ) {
    HRESULT _hr = raw_SetRasterSymbol(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(589)
inline double IImageryLayer::GetDrawOrder ( ) {
    double _result = 0;
    HRESULT _hr = get_DrawOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(590)
inline void IImageryLayer::PutDrawOrder ( double pVal ) {
    HRESULT _hr = put_DrawOrder(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(591)
inline double IImageryLayer::GetOpacity ( ) {
    double _result = 0;
    HRESULT _hr = get_Opacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(592)
inline void IImageryLayer::PutOpacity ( double pVal ) {
    HRESULT _hr = put_Opacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(593)
inline long IImageryLayer::GetBandCount ( ) {
    long _result = 0;
    HRESULT _hr = get_BandCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(594)
inline VARIANT_BOOL IImageryLayer::Valid ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Valid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(595)
inline HRESULT IImageryLayer::GetExtent ( double * Left, double * Right, double * Bottom, double * Top ) {
    HRESULT _hr = raw_GetExtent(Left, Right, Bottom, Top);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(596)
inline HRESULT IImageryLayer::GetResolution ( double * ResolutionX, double * ResolutionY ) {
    HRESULT _hr = raw_GetResolution(ResolutionX, ResolutionY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ITerrainHole wrapper method implementations
//

#pragma implementation_key(597)
inline IPolygonPtr ITerrainHole::GetPolygon ( ) {
    struct IPolygon * _result = 0;
    HRESULT _hr = raw_GetPolygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPolygonPtr(_result, false);
}

#pragma implementation_key(598)
inline HRESULT ITerrainHole::SetPolygon ( struct IPolygon * newVal ) {
    HRESULT _hr = raw_SetPolygon(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(599)
inline long ITerrainHole::GetDrawOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_DrawOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(600)
inline void ITerrainHole::PutDrawOrder ( long pVal ) {
    HRESULT _hr = put_DrawOrder(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface I3DTileHole wrapper method implementations
//

#pragma implementation_key(601)
inline IPolygonPtr I3DTileHole::GetPolygon ( ) {
    struct IPolygon * _result = 0;
    HRESULT _hr = raw_GetPolygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPolygonPtr(_result, false);
}

#pragma implementation_key(602)
inline HRESULT I3DTileHole::SetPolygon ( struct IPolygon * newVal ) {
    HRESULT _hr = raw_SetPolygon(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(603)
inline long I3DTileHole::GetDrawOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_DrawOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(604)
inline void I3DTileHole::PutDrawOrder ( long pVal ) {
    HRESULT _hr = put_DrawOrder(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface I3DTileLayer wrapper method implementations
//

#pragma implementation_key(605)
inline IPropertySetPtr I3DTileLayer::GetRenderParams ( ) {
    struct IPropertySet * _result = 0;
    HRESULT _hr = get_RenderParams(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPropertySetPtr(_result, false);
}

#pragma implementation_key(606)
inline void I3DTileLayer::PutRenderParams ( struct IPropertySet * pVal ) {
    HRESULT _hr = put_RenderParams(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(607)
inline _bstr_t I3DTileLayer::GetConnectionInfo ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConnectionInfo(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(608)
inline _bstr_t I3DTileLayer::GetWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IOverlayLabel wrapper method implementations
//

#pragma implementation_key(609)
inline _bstr_t IOverlayLabel::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(610)
inline void IOverlayLabel::PutText ( _bstr_t pVal ) {
    HRESULT _hr = put_Text(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(611)
inline ITextAttributePtr IOverlayLabel::GetTextStyle ( ) {
    struct ITextAttribute * _result = 0;
    HRESULT _hr = get_TextStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextAttributePtr(_result, false);
}

#pragma implementation_key(612)
inline void IOverlayLabel::PutTextStyle ( struct ITextAttribute * pVal ) {
    HRESULT _hr = put_TextStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(613)
inline enum gviPivotAlignment IOverlayLabel::GetAlignment ( ) {
    enum gviPivotAlignment _result;
    HRESULT _hr = get_Alignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(614)
inline void IOverlayLabel::PutAlignment ( enum gviPivotAlignment pVal ) {
    HRESULT _hr = put_Alignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(615)
inline _bstr_t IOverlayLabel::GetImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(616)
inline void IOverlayLabel::PutImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_ImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(617)
inline HRESULT IOverlayLabel::SetX ( long Offset, float WindowWidthRatio, float WindowHeightRatio ) {
    HRESULT _hr = raw_SetX(Offset, WindowWidthRatio, WindowHeightRatio);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(618)
inline HRESULT IOverlayLabel::SetY ( long Offset, float WindowWidthRatio, float WindowHeightRatio ) {
    HRESULT _hr = raw_SetY(Offset, WindowWidthRatio, WindowHeightRatio);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(619)
inline HRESULT IOverlayLabel::SetWidth ( long Offset, float WindowWidthRatio, float WindowHeightRatio ) {
    HRESULT _hr = raw_SetWidth(Offset, WindowWidthRatio, WindowHeightRatio);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(620)
inline HRESULT IOverlayLabel::SetHeight ( long Offset, float WindowWidthRatio, float WindowHeightRatio ) {
    HRESULT _hr = raw_SetHeight(Offset, WindowWidthRatio, WindowHeightRatio);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(621)
inline long IOverlayLabel::GetX ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(622)
inline long IOverlayLabel::GetY ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(623)
inline long IOverlayLabel::GetWidth ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(624)
inline long IOverlayLabel::GetHeight ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(625)
inline float IOverlayLabel::GetRotation ( ) {
    float _result = 0;
    HRESULT _hr = get_Rotation(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(626)
inline void IOverlayLabel::PutRotation ( float pVal ) {
    HRESULT _hr = put_Rotation(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(627)
inline float IOverlayLabel::GetDepth ( ) {
    float _result = 0;
    HRESULT _hr = get_Depth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(628)
inline void IOverlayLabel::PutDepth ( float pVal ) {
    HRESULT _hr = put_Depth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainVideo wrapper method implementations
//

#pragma implementation_key(629)
inline IPointPtr ITerrainVideo::GetPosition ( ) {
    struct IPoint * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(630)
inline void ITerrainVideo::PutPosition ( struct IPoint * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(631)
inline IEulerAnglePtr ITerrainVideo::GetAngle ( ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(632)
inline void ITerrainVideo::PutAngle ( struct IEulerAngle * pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(633)
inline double ITerrainVideo::GetFarClip ( ) {
    double _result = 0;
    HRESULT _hr = get_FarClip(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(634)
inline void ITerrainVideo::PutFarClip ( double pVal ) {
    HRESULT _hr = put_FarClip(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(635)
inline double ITerrainVideo::GetFieldOfView ( ) {
    double _result = 0;
    HRESULT _hr = get_FieldOfView(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(636)
inline void ITerrainVideo::PutFieldOfView ( double pVal ) {
    HRESULT _hr = put_FieldOfView(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(637)
inline double ITerrainVideo::GetAspectRatio ( ) {
    double _result = 0;
    HRESULT _hr = get_AspectRatio(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(638)
inline void ITerrainVideo::PutAspectRatio ( double pVal ) {
    HRESULT _hr = put_AspectRatio(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(639)
inline VARIANT_BOOL ITerrainVideo::GetShowProjector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowProjector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(640)
inline void ITerrainVideo::PutShowProjector ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowProjector(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(641)
inline VARIANT_BOOL ITerrainVideo::GetShowProjectionLines ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowProjectionLines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(642)
inline void ITerrainVideo::PutShowProjectionLines ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowProjectionLines(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(643)
inline _bstr_t ITerrainVideo::GetVideoFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_VideoFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(644)
inline void ITerrainVideo::PutVideoFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_VideoFileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(645)
inline double ITerrainVideo::GetVideoLength ( ) {
    double _result = 0;
    HRESULT _hr = get_VideoLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(646)
inline double ITerrainVideo::GetVideoOpacity ( ) {
    double _result = 0;
    HRESULT _hr = get_VideoOpacity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(647)
inline void ITerrainVideo::PutVideoOpacity ( double pVal ) {
    HRESULT _hr = put_VideoOpacity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(648)
inline double ITerrainVideo::GetVideoPosition ( ) {
    double _result = 0;
    HRESULT _hr = get_VideoPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(649)
inline void ITerrainVideo::PutVideoPosition ( double pVal ) {
    HRESULT _hr = put_VideoPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(650)
inline long ITerrainVideo::GetPlayStatus ( ) {
    long _result = 0;
    HRESULT _hr = get_PlayStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(651)
inline VARIANT_BOOL ITerrainVideo::GetCanSeek ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CanSeek(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(652)
inline VARIANT_BOOL ITerrainVideo::GetPlayVideoOnStartup ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PlayVideoOnStartup(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(653)
inline void ITerrainVideo::PutPlayVideoOnStartup ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PlayVideoOnStartup(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(654)
inline double ITerrainVideo::GetPlaybackRate ( ) {
    double _result = 0;
    HRESULT _hr = get_PlaybackRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(655)
inline void ITerrainVideo::PutPlaybackRate ( double pVal ) {
    HRESULT _hr = put_PlaybackRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(656)
inline VARIANT_BOOL ITerrainVideo::GetPlayLoop ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PlayLoop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(657)
inline void ITerrainVideo::PutPlayLoop ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_PlayLoop(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(658)
inline _bstr_t ITerrainVideo::GetIcon ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Icon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(659)
inline void ITerrainVideo::PutIcon ( _bstr_t pVal ) {
    HRESULT _hr = put_Icon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IViewshed wrapper method implementations
//

#pragma implementation_key(660)
inline IPointPtr IViewshed::GetPosition ( ) {
    struct IPoint * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(661)
inline void IViewshed::PutPosition ( struct IPoint * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(662)
inline IEulerAnglePtr IViewshed::GetAngle ( ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = get_Angle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(663)
inline void IViewshed::PutAngle ( struct IEulerAngle * pVal ) {
    HRESULT _hr = put_Angle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(664)
inline double IViewshed::GetFarClip ( ) {
    double _result = 0;
    HRESULT _hr = get_FarClip(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(665)
inline void IViewshed::PutFarClip ( double pVal ) {
    HRESULT _hr = put_FarClip(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(666)
inline double IViewshed::GetFieldOfView ( ) {
    double _result = 0;
    HRESULT _hr = get_FieldOfView(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(667)
inline void IViewshed::PutFieldOfView ( double pVal ) {
    HRESULT _hr = put_FieldOfView(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(668)
inline double IViewshed::GetAspectRatio ( ) {
    double _result = 0;
    HRESULT _hr = get_AspectRatio(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(669)
inline void IViewshed::PutAspectRatio ( double pVal ) {
    HRESULT _hr = put_AspectRatio(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(670)
inline VARIANT_BOOL IViewshed::GetShowProjector ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowProjector(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(671)
inline void IViewshed::PutShowProjector ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowProjector(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(672)
inline VARIANT_BOOL IViewshed::GetShowProjectionLines ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowProjectionLines(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(673)
inline void IViewshed::PutShowProjectionLines ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowProjectionLines(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(674)
inline _bstr_t IViewshed::GetIcon ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Icon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(675)
inline void IViewshed::PutIcon ( _bstr_t pVal ) {
    HRESULT _hr = put_Icon(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderArrow wrapper method implementations
//

#pragma implementation_key(676)
inline enum gviArrowType IRenderArrow::GetArrowType ( ) {
    enum gviArrowType _result;
    HRESULT _hr = get_ArrowType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(677)
inline void IRenderArrow::PutArrowType ( enum gviArrowType pVal ) {
    HRESULT _hr = put_ArrowType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(678)
inline ISurfaceSymbolPtr IRenderArrow::GetSymbol ( ) {
    struct ISurfaceSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISurfaceSymbolPtr(_result, false);
}

#pragma implementation_key(679)
inline void IRenderArrow::PutSymbol ( struct ISurfaceSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(680)
inline double IRenderArrow::GetHeadHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_HeadHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(681)
inline void IRenderArrow::PutHeadHeight ( double pVal ) {
    HRESULT _hr = put_HeadHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(682)
inline double IRenderArrow::GetBottomWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_BottomWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(683)
inline void IRenderArrow::PutBottomWidth ( double pVal ) {
    HRESULT _hr = put_BottomWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(684)
inline double IRenderArrow::GetWingAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_WingAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(685)
inline void IRenderArrow::PutWingAngle ( double pVal ) {
    HRESULT _hr = put_WingAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(686)
inline double IRenderArrow::GetWingLength ( ) {
    double _result = 0;
    HRESULT _hr = get_WingLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(687)
inline void IRenderArrow::PutWingLength ( double pVal ) {
    HRESULT _hr = put_WingLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(688)
inline double IRenderArrow::GetWingBottomLength ( ) {
    double _result = 0;
    HRESULT _hr = get_WingBottomLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(689)
inline void IRenderArrow::PutWingBottomLength ( double pVal ) {
    HRESULT _hr = put_WingBottomLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(690)
inline double IRenderArrow::GetTolerance ( ) {
    double _result = 0;
    HRESULT _hr = get_Tolerance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(691)
inline void IRenderArrow::PutTolerance ( double pVal ) {
    HRESULT _hr = put_Tolerance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(692)
inline double IRenderArrow::GetChordHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_ChordHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(693)
inline void IRenderArrow::PutChordHeight ( double pVal ) {
    HRESULT _hr = put_ChordHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(694)
inline VARIANT_BOOL IRenderArrow::GetDualArrowFollow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DualArrowFollow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(695)
inline void IRenderArrow::PutDualArrowFollow ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_DualArrowFollow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(696)
inline HRESULT IRenderArrow::AddPoint ( struct IPoint * newVal ) {
    HRESULT _hr = raw_AddPoint(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IDynamicObject wrapper method implementations
//

#pragma implementation_key(697)
inline VARIANT_BOOL IDynamicObject::AddWaypoint ( struct IVector3 * Position, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddWaypoint(Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(698)
inline VARIANT_BOOL IDynamicObject::AddWaypoint2 ( struct IPoint * Position, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddWaypoint2(Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(699)
inline _bstr_t IDynamicObject::AsXml ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_AsXml(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(700)
inline HRESULT IDynamicObject::ClearWaypoints ( ) {
    HRESULT _hr = raw_ClearWaypoints();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(701)
inline VARIANT_BOOL IDynamicObject::DeleteWaypoint ( long Index ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteWaypoint(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(702)
inline VARIANT_BOOL IDynamicObject::FromXml ( _bstr_t XmlStringValue ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_FromXml(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(703)
inline VARIANT_BOOL IDynamicObject::GetWaypoint ( long Index, struct IVector3 * * Position, double * Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetWaypoint(Index, Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(704)
inline VARIANT_BOOL IDynamicObject::GetWaypoint2 ( long Index, struct IPoint * * Position, double * Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_GetWaypoint2(Index, Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(705)
inline VARIANT_BOOL IDynamicObject::ModifyWaypoint ( long Index, struct IVector3 * Position, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ModifyWaypoint(Index, Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(706)
inline VARIANT_BOOL IDynamicObject::ModifyWaypoint2 ( long Index, struct IPoint * Position, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ModifyWaypoint2(Index, Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(707)
inline VARIANT_BOOL IDynamicObject::InsertWaypoint ( long Index, struct IVector3 * Position, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InsertWaypoint(Index, Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(708)
inline VARIANT_BOOL IDynamicObject::InsertWaypoint2 ( long Index, struct IPoint * Position, double Speed ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_InsertWaypoint2(Index, Position, Speed, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(709)
inline HRESULT IDynamicObject::Play ( ) {
    HRESULT _hr = raw_Play();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(710)
inline HRESULT IDynamicObject::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(711)
inline HRESULT IDynamicObject::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(712)
inline VARIANT_BOOL IDynamicObject::GetAutoRepeat ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AutoRepeat(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(713)
inline void IDynamicObject::PutAutoRepeat ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_AutoRepeat(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(714)
inline _bstr_t IDynamicObject::GetCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(715)
inline void IDynamicObject::PutCrsWKT ( _bstr_t pVal ) {
    HRESULT _hr = put_CrsWKT(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(716)
inline long IDynamicObject::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(717)
inline void IDynamicObject::PutIndex ( long pVal ) {
    HRESULT _hr = put_Index(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(718)
inline long IDynamicObject::GetWaypointsNumber ( ) {
    long _result = 0;
    HRESULT _hr = get_WaypointsNumber(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(719)
inline double IDynamicObject::GetTurnSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_TurnSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(720)
inline void IDynamicObject::PutTurnSpeed ( double pVal ) {
    HRESULT _hr = put_TurnSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(721)
inline enum gviDynamicMotionStyle IDynamicObject::GetMotionStyle ( ) {
    enum gviDynamicMotionStyle _result;
    HRESULT _hr = get_MotionStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(722)
inline void IDynamicObject::PutMotionStyle ( enum gviDynamicMotionStyle pVal ) {
    HRESULT _hr = put_MotionStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainModifier wrapper method implementations
//

#pragma implementation_key(723)
inline IPolygonPtr ITerrainModifier::GetPolygon ( ) {
    struct IPolygon * _result = 0;
    HRESULT _hr = raw_GetPolygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPolygonPtr(_result, false);
}

#pragma implementation_key(724)
inline HRESULT ITerrainModifier::SetPolygon ( struct IPolygon * newVal ) {
    HRESULT _hr = raw_SetPolygon(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(725)
inline enum gviElevationBehaviorMode ITerrainModifier::GetElevationBehavior ( ) {
    enum gviElevationBehaviorMode _result;
    HRESULT _hr = get_ElevationBehavior(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(726)
inline void ITerrainModifier::PutElevationBehavior ( enum gviElevationBehaviorMode pVal ) {
    HRESULT _hr = put_ElevationBehavior(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(727)
inline long ITerrainModifier::GetDrawOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_DrawOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(728)
inline void ITerrainModifier::PutDrawOrder ( long pVal ) {
    HRESULT _hr = put_DrawOrder(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPosition wrapper method implementations
//

#pragma implementation_key(729)
inline double IPosition::GetX ( ) {
    double _result = 0;
    HRESULT _hr = get_X(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(730)
inline void IPosition::PutX ( double pVal ) {
    HRESULT _hr = put_X(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(731)
inline double IPosition::GetY ( ) {
    double _result = 0;
    HRESULT _hr = get_Y(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(732)
inline void IPosition::PutY ( double pVal ) {
    HRESULT _hr = put_Y(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(733)
inline double IPosition::GetHeading ( ) {
    double _result = 0;
    HRESULT _hr = get_Heading(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(734)
inline void IPosition::PutHeading ( double pVal ) {
    HRESULT _hr = put_Heading(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(735)
inline double IPosition::GetTilt ( ) {
    double _result = 0;
    HRESULT _hr = get_Tilt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(736)
inline void IPosition::PutTilt ( double pVal ) {
    HRESULT _hr = put_Tilt(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(737)
inline double IPosition::GetRoll ( ) {
    double _result = 0;
    HRESULT _hr = get_Roll(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(738)
inline void IPosition::PutRoll ( double pVal ) {
    HRESULT _hr = put_Roll(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(739)
inline double IPosition::GetAltitude ( ) {
    double _result = 0;
    HRESULT _hr = get_Altitude(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(740)
inline void IPosition::PutAltitude ( double pVal ) {
    HRESULT _hr = put_Altitude(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(741)
inline VARIANT_BOOL IPosition::GetCartesian ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Cartesian(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(742)
inline void IPosition::PutCartesian ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Cartesian(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(743)
inline enum gviAltitudeType IPosition::GetAltitudeType ( ) {
    enum gviAltitudeType _result;
    HRESULT _hr = get_AltitudeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(744)
inline void IPosition::PutAltitudeType ( enum gviAltitudeType pVal ) {
    HRESULT _hr = put_AltitudeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(745)
inline HRESULT IPosition::Init ( double X, double Y, double Altitude, double Heading, double Tilt, double Roll, enum gviAltitudeType AltitudeType ) {
    HRESULT _hr = raw_Init(X, Y, Altitude, Heading, Tilt, Roll, AltitudeType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(746)
inline double IPosition::GetDistance ( ) {
    double _result = 0;
    HRESULT _hr = get_Distance(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(747)
inline void IPosition::PutDistance ( double pVal ) {
    HRESULT _hr = put_Distance(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IObjectTexture wrapper method implementations
//

#pragma implementation_key(748)
inline double IObjectTexture::GetRotateAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_RotateAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(749)
inline void IObjectTexture::PutRotateAngle ( double pVal ) {
    HRESULT _hr = put_RotateAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(750)
inline double IObjectTexture::GetScaleX ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(751)
inline void IObjectTexture::PutScaleX ( double pVal ) {
    HRESULT _hr = put_ScaleX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(752)
inline double IObjectTexture::GetScaleY ( ) {
    double _result = 0;
    HRESULT _hr = get_ScaleY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(753)
inline void IObjectTexture::PutScaleY ( double pVal ) {
    HRESULT _hr = put_ScaleY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(754)
inline _bstr_t IObjectTexture::GetFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(755)
inline void IObjectTexture::PutFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_FileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IFillStyle wrapper method implementations
//

#pragma implementation_key(756)
inline OLE_COLOR IFillStyle::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(757)
inline void IFillStyle::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(758)
inline IObjectTexturePtr IFillStyle::GetTexture ( ) {
    struct IObjectTexture * _result = 0;
    HRESULT _hr = get_Texture(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IObjectTexturePtr(_result, false);
}

#pragma implementation_key(759)
inline void IFillStyle::PutTexture ( struct IObjectTexture * pVal ) {
    HRESULT _hr = put_Texture(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ILineStyle wrapper method implementations
//

#pragma implementation_key(760)
inline OLE_COLOR ILineStyle::GetBackColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(761)
inline void ILineStyle::PutBackColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(762)
inline OLE_COLOR ILineStyle::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(763)
inline void ILineStyle::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(764)
inline enum gviDashStyle ILineStyle::GetPattern ( ) {
    enum gviDashStyle _result;
    HRESULT _hr = get_Pattern(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(765)
inline void ILineStyle::PutPattern ( enum gviDashStyle pVal ) {
    HRESULT _hr = put_Pattern(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(766)
inline double ILineStyle::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(767)
inline void ILineStyle::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainRegularPolygon wrapper method implementations
//

#pragma implementation_key(768)
inline long ITerrainRegularPolygon::GetNumberOfSegments ( ) {
    long _result = 0;
    HRESULT _hr = get_NumberOfSegments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(769)
inline void ITerrainRegularPolygon::PutNumberOfSegments ( long pVal ) {
    HRESULT _hr = put_NumberOfSegments(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(770)
inline double ITerrainRegularPolygon::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(771)
inline void ITerrainRegularPolygon::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(772)
inline IFillStylePtr ITerrainRegularPolygon::GetFillStyle ( ) {
    struct IFillStyle * _result = 0;
    HRESULT _hr = get_FillStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFillStylePtr(_result, false);
}

#pragma implementation_key(773)
inline void ITerrainRegularPolygon::PutFillStyle ( struct IFillStyle * pVal ) {
    HRESULT _hr = put_FillStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(774)
inline ILineStylePtr ITerrainRegularPolygon::GetLineStyle ( ) {
    struct ILineStyle * _result = 0;
    HRESULT _hr = get_LineStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILineStylePtr(_result, false);
}

#pragma implementation_key(775)
inline void ITerrainRegularPolygon::PutLineStyle ( struct ILineStyle * pVal ) {
    HRESULT _hr = put_LineStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(776)
inline IPositionPtr ITerrainRegularPolygon::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(777)
inline void ITerrainRegularPolygon::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(778)
inline IGeometryCollectionPtr ITerrainRegularPolygon::GetFdeGeometry ( ) {
    struct IGeometryCollection * _result = 0;
    HRESULT _hr = raw_GetFdeGeometry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryCollectionPtr(_result, false);
}

//
// interface ITerrain3DRegBase wrapper method implementations
//

#pragma implementation_key(779)
inline double ITerrain3DRegBase::GetHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(780)
inline void ITerrain3DRegBase::PutHeight ( double pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainArrow wrapper method implementations
//

#pragma implementation_key(781)
inline double ITerrainArrow::GetHeadX ( ) {
    double _result = 0;
    HRESULT _hr = get_HeadX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(782)
inline void ITerrainArrow::PutHeadX ( double pVal ) {
    HRESULT _hr = put_HeadX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(783)
inline double ITerrainArrow::GetHeadY ( ) {
    double _result = 0;
    HRESULT _hr = get_HeadY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(784)
inline void ITerrainArrow::PutHeadY ( double pVal ) {
    HRESULT _hr = put_HeadY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(785)
inline double ITerrainArrow::GetTailX ( ) {
    double _result = 0;
    HRESULT _hr = get_TailX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(786)
inline void ITerrainArrow::PutTailX ( double pVal ) {
    HRESULT _hr = put_TailX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(787)
inline double ITerrainArrow::GetTailY ( ) {
    double _result = 0;
    HRESULT _hr = get_TailY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(788)
inline void ITerrainArrow::PutTailY ( double pVal ) {
    HRESULT _hr = put_TailY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(789)
inline IFillStylePtr ITerrainArrow::GetFillStyle ( ) {
    struct IFillStyle * _result = 0;
    HRESULT _hr = get_FillStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFillStylePtr(_result, false);
}

#pragma implementation_key(790)
inline void ITerrainArrow::PutFillStyle ( struct IFillStyle * pVal ) {
    HRESULT _hr = put_FillStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(791)
inline ILineStylePtr ITerrainArrow::GetLineStyle ( ) {
    struct ILineStyle * _result = 0;
    HRESULT _hr = get_LineStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILineStylePtr(_result, false);
}

#pragma implementation_key(792)
inline void ITerrainArrow::PutLineStyle ( struct ILineStyle * pVal ) {
    HRESULT _hr = put_LineStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(793)
inline IPositionPtr ITerrainArrow::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(794)
inline void ITerrainArrow::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(795)
inline unsigned char ITerrainArrow::GetStyle ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(796)
inline void ITerrainArrow::PutStyle ( unsigned char pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(797)
inline IGeometryCollectionPtr ITerrainArrow::GetFdeGeometry ( ) {
    struct IGeometryCollection * _result = 0;
    HRESULT _hr = raw_GetFdeGeometry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryCollectionPtr(_result, false);
}

//
// interface ITerrain3DArrow wrapper method implementations
//

#pragma implementation_key(798)
inline double ITerrain3DArrow::GetHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(799)
inline void ITerrain3DArrow::PutHeight ( double pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainRectangle wrapper method implementations
//

#pragma implementation_key(800)
inline double ITerrainRectangle::GetWidth ( ) {
    double _result = 0;
    HRESULT _hr = get_Width(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(801)
inline void ITerrainRectangle::PutWidth ( double pVal ) {
    HRESULT _hr = put_Width(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(802)
inline double ITerrainRectangle::GetDepth ( ) {
    double _result = 0;
    HRESULT _hr = get_Depth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(803)
inline void ITerrainRectangle::PutDepth ( double pVal ) {
    HRESULT _hr = put_Depth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(804)
inline double ITerrainRectangle::GetLeft ( ) {
    double _result = 0;
    HRESULT _hr = get_Left(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(805)
inline void ITerrainRectangle::PutLeft ( double pVal ) {
    HRESULT _hr = put_Left(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(806)
inline double ITerrainRectangle::GetTop ( ) {
    double _result = 0;
    HRESULT _hr = get_Top(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(807)
inline void ITerrainRectangle::PutTop ( double pVal ) {
    HRESULT _hr = put_Top(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(808)
inline double ITerrainRectangle::GetRight ( ) {
    double _result = 0;
    HRESULT _hr = get_Right(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(809)
inline void ITerrainRectangle::PutRight ( double pVal ) {
    HRESULT _hr = put_Right(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(810)
inline double ITerrainRectangle::GetBottom ( ) {
    double _result = 0;
    HRESULT _hr = get_Bottom(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(811)
inline void ITerrainRectangle::PutBottom ( double pVal ) {
    HRESULT _hr = put_Bottom(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(812)
inline IFillStylePtr ITerrainRectangle::GetFillStyle ( ) {
    struct IFillStyle * _result = 0;
    HRESULT _hr = get_FillStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFillStylePtr(_result, false);
}

#pragma implementation_key(813)
inline void ITerrainRectangle::PutFillStyle ( struct IFillStyle * pVal ) {
    HRESULT _hr = put_FillStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(814)
inline ILineStylePtr ITerrainRectangle::GetLineStyle ( ) {
    struct ILineStyle * _result = 0;
    HRESULT _hr = get_LineStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILineStylePtr(_result, false);
}

#pragma implementation_key(815)
inline void ITerrainRectangle::PutLineStyle ( struct ILineStyle * pVal ) {
    HRESULT _hr = put_LineStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(816)
inline IPositionPtr ITerrainRectangle::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(817)
inline void ITerrainRectangle::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(818)
inline IGeometryCollectionPtr ITerrainRectangle::GetFdeGeometry ( ) {
    struct IGeometryCollection * _result = 0;
    HRESULT _hr = raw_GetFdeGeometry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryCollectionPtr(_result, false);
}

//
// interface ITerrain3DRectBase wrapper method implementations
//

#pragma implementation_key(819)
inline double ITerrain3DRectBase::GetHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(820)
inline void ITerrain3DRectBase::PutHeight ( double pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainEllipse wrapper method implementations
//

#pragma implementation_key(821)
inline IFillStylePtr ITerrainEllipse::GetFillStyle ( ) {
    struct IFillStyle * _result = 0;
    HRESULT _hr = get_FillStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFillStylePtr(_result, false);
}

#pragma implementation_key(822)
inline void ITerrainEllipse::PutFillStyle ( struct IFillStyle * pVal ) {
    HRESULT _hr = put_FillStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(823)
inline ILineStylePtr ITerrainEllipse::GetLineStyle ( ) {
    struct ILineStyle * _result = 0;
    HRESULT _hr = get_LineStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILineStylePtr(_result, false);
}

#pragma implementation_key(824)
inline void ITerrainEllipse::PutLineStyle ( struct ILineStyle * pVal ) {
    HRESULT _hr = put_LineStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(825)
inline IPositionPtr ITerrainEllipse::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(826)
inline void ITerrainEllipse::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(827)
inline long ITerrainEllipse::GetNumberOfSegments ( ) {
    long _result = 0;
    HRESULT _hr = get_NumberOfSegments(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(828)
inline void ITerrainEllipse::PutNumberOfSegments ( long pVal ) {
    HRESULT _hr = put_NumberOfSegments(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(829)
inline double ITerrainEllipse::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(830)
inline void ITerrainEllipse::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(831)
inline double ITerrainEllipse::GetRadius2 ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius2(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(832)
inline void ITerrainEllipse::PutRadius2 ( double pVal ) {
    HRESULT _hr = put_Radius2(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(833)
inline IGeometryCollectionPtr ITerrainEllipse::GetFdeGeometry ( ) {
    struct IGeometryCollection * _result = 0;
    HRESULT _hr = raw_GetFdeGeometry(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryCollectionPtr(_result, false);
}

//
// interface ITerrainArc wrapper method implementations
//

#pragma implementation_key(834)
inline double ITerrainArc::GetStartAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_StartAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(835)
inline void ITerrainArc::PutStartAngle ( double pVal ) {
    HRESULT _hr = put_StartAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(836)
inline double ITerrainArc::GetEndAngle ( ) {
    double _result = 0;
    HRESULT _hr = get_EndAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(837)
inline void ITerrainArc::PutEndAngle ( double pVal ) {
    HRESULT _hr = put_EndAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainSphere wrapper method implementations
//

#pragma implementation_key(838)
inline IFillStylePtr ITerrainSphere::GetFillStyle ( ) {
    struct IFillStyle * _result = 0;
    HRESULT _hr = get_FillStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFillStylePtr(_result, false);
}

#pragma implementation_key(839)
inline void ITerrainSphere::PutFillStyle ( struct IFillStyle * pVal ) {
    HRESULT _hr = put_FillStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(840)
inline ILineStylePtr ITerrainSphere::GetLineStyle ( ) {
    struct ILineStyle * _result = 0;
    HRESULT _hr = get_LineStyle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILineStylePtr(_result, false);
}

#pragma implementation_key(841)
inline void ITerrainSphere::PutLineStyle ( struct ILineStyle * pVal ) {
    HRESULT _hr = put_LineStyle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(842)
inline IPositionPtr ITerrainSphere::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(843)
inline void ITerrainSphere::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(844)
inline double ITerrainSphere::GetRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_Radius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(845)
inline void ITerrainSphere::PutRadius ( double pVal ) {
    HRESULT _hr = put_Radius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(846)
inline long ITerrainSphere::GetSegmentDensity ( ) {
    long _result = 0;
    HRESULT _hr = get_SegmentDensity(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(847)
inline void ITerrainSphere::PutSegmentDensity ( long pVal ) {
    HRESULT _hr = put_SegmentDensity(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(848)
inline long ITerrainSphere::GetStyle ( ) {
    long _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(849)
inline void ITerrainSphere::PutStyle ( long pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainLocation wrapper method implementations
//

#pragma implementation_key(850)
inline IPositionPtr ITerrainLocation::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(851)
inline void ITerrainLocation::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(852)
inline _bstr_t ITerrainLocation::GetSlideImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SlideImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(853)
inline void ITerrainLocation::PutSlideImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_SlideImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ILabelStyle wrapper method implementations
//

#pragma implementation_key(854)
inline enum gviLineToGroundType ILabelStyle::GetLineToGround ( ) {
    enum gviLineToGroundType _result;
    HRESULT _hr = get_LineToGround(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(855)
inline void ILabelStyle::PutLineToGround ( enum gviLineToGroundType pVal ) {
    HRESULT _hr = put_LineToGround(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(856)
inline double ILabelStyle::GetLineLength ( ) {
    double _result = 0;
    HRESULT _hr = get_LineLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(857)
inline void ILabelStyle::PutLineLength ( double pVal ) {
    HRESULT _hr = put_LineLength(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(858)
inline OLE_COLOR ILabelStyle::GetLineColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_LineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(859)
inline void ILabelStyle::PutLineColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_LineColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(860)
inline OLE_COLOR ILabelStyle::GetTextColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_TextColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(861)
inline void ILabelStyle::PutTextColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_TextColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(862)
inline long ILabelStyle::GetFontSize ( ) {
    long _result = 0;
    HRESULT _hr = get_FontSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(863)
inline void ILabelStyle::PutFontSize ( long pVal ) {
    HRESULT _hr = put_FontSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(864)
inline _bstr_t ILabelStyle::GetFontName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FontName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(865)
inline void ILabelStyle::PutFontName ( _bstr_t pVal ) {
    HRESULT _hr = put_FontName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(866)
inline VARIANT_BOOL ILabelStyle::GetBold ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Bold(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(867)
inline void ILabelStyle::PutBold ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Bold(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(868)
inline VARIANT_BOOL ILabelStyle::GetUnderline ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Underline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(869)
inline void ILabelStyle::PutUnderline ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Underline(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(870)
inline VARIANT_BOOL ILabelStyle::GetItalic ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Italic(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(871)
inline void ILabelStyle::PutItalic ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Italic(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(872)
inline enum gviMultilineJustification ILabelStyle::GetMultilineJustification ( ) {
    enum gviMultilineJustification _result;
    HRESULT _hr = get_MultilineJustification(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(873)
inline void ILabelStyle::PutMultilineJustification ( enum gviMultilineJustification pVal ) {
    HRESULT _hr = put_MultilineJustification(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(874)
inline VARIANT_BOOL ILabelStyle::GetTextOnImage ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_TextOnImage(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(875)
inline void ILabelStyle::PutTextOnImage ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_TextOnImage(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(876)
inline _bstr_t ILabelStyle::GetTextAlignment ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_TextAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(877)
inline void ILabelStyle::PutTextAlignment ( _bstr_t pVal ) {
    HRESULT _hr = put_TextAlignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(878)
inline enum gviShowTextOptions ILabelStyle::GetShowTextBehavior ( ) {
    enum gviShowTextOptions _result;
    HRESULT _hr = get_ShowTextBehavior(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(879)
inline void ILabelStyle::PutShowTextBehavior ( enum gviShowTextOptions pVal ) {
    HRESULT _hr = put_ShowTextBehavior(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(880)
inline OLE_COLOR ILabelStyle::GetIconColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_IconColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(881)
inline void ILabelStyle::PutIconColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_IconColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(882)
inline OLE_COLOR ILabelStyle::GetBackgroundColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_BackgroundColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(883)
inline void ILabelStyle::PutBackgroundColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_BackgroundColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(884)
inline long ILabelStyle::GetMaxImageSize ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxImageSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(885)
inline void ILabelStyle::PutMaxImageSize ( long pVal ) {
    HRESULT _hr = put_MaxImageSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(886)
inline _bstr_t ILabelStyle::GetFrameFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FrameFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(887)
inline void ILabelStyle::PutFrameFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_FrameFileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(888)
inline enum gviLockMode ILabelStyle::GetLockMode ( ) {
    enum gviLockMode _result;
    HRESULT _hr = get_LockMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(889)
inline void ILabelStyle::PutLockMode ( enum gviLockMode pVal ) {
    HRESULT _hr = put_LockMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(890)
inline double ILabelStyle::GetScale ( ) {
    double _result = 0;
    HRESULT _hr = get_Scale(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(891)
inline void ILabelStyle::PutScale ( double pVal ) {
    HRESULT _hr = put_Scale(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(892)
inline VARIANT_BOOL ILabelStyle::GetLimitScreenSize ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LimitScreenSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(893)
inline void ILabelStyle::PutLimitScreenSize ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LimitScreenSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(894)
inline double ILabelStyle::GetMinViewingHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_MinViewingHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(895)
inline void ILabelStyle::PutMinViewingHeight ( double pVal ) {
    HRESULT _hr = put_MinViewingHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(896)
inline double ILabelStyle::GetMaxViewingHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxViewingHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(897)
inline void ILabelStyle::PutMaxViewingHeight ( double pVal ) {
    HRESULT _hr = put_MaxViewingHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(898)
inline enum gviPivotAlignment ILabelStyle::GetPivotAlignment ( ) {
    enum gviPivotAlignment _result;
    HRESULT _hr = get_PivotAlignment(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(899)
inline void ILabelStyle::PutPivotAlignment ( enum gviPivotAlignment pVal ) {
    HRESULT _hr = put_PivotAlignment(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainImageLabel wrapper method implementations
//

#pragma implementation_key(900)
inline ILabelStylePtr ITerrainImageLabel::GetStyle ( ) {
    struct ILabelStyle * _result = 0;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILabelStylePtr(_result, false);
}

#pragma implementation_key(901)
inline void ITerrainImageLabel::PutStyle ( struct ILabelStyle * pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(902)
inline IPositionPtr ITerrainImageLabel::GetPosition ( ) {
    struct IPosition * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPositionPtr(_result, false);
}

#pragma implementation_key(903)
inline void ITerrainImageLabel::PutPosition ( struct IPosition * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(904)
inline _bstr_t ITerrainImageLabel::GetImageFileName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ImageFileName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(905)
inline void ITerrainImageLabel::PutImageFileName ( _bstr_t pVal ) {
    HRESULT _hr = put_ImageFileName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IPresentationStep wrapper method implementations
//

#pragma implementation_key(906)
inline _bstr_t IPresentationStep::GetCaptionText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_CaptionText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(907)
inline void IPresentationStep::PutCaptionText ( _bstr_t pVal ) {
    HRESULT _hr = put_CaptionText(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(908)
inline long IPresentationStep::GetCaptionTimeout ( ) {
    long _result = 0;
    HRESULT _hr = get_CaptionTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(909)
inline void IPresentationStep::PutCaptionTimeout ( long pVal ) {
    HRESULT _hr = put_CaptionTimeout(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(910)
inline enum gviPresentationStepContinue IPresentationStep::GetContinue ( ) {
    enum gviPresentationStepContinue _result;
    HRESULT _hr = get_Continue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(911)
inline void IPresentationStep::PutContinue ( enum gviPresentationStepContinue pVal ) {
    HRESULT _hr = put_Continue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(912)
inline _bstr_t IPresentationStep::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(913)
inline void IPresentationStep::PutDescription ( _bstr_t pVal ) {
    HRESULT _hr = put_Description(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(914)
inline enum gviPresentationStepFlightSpeed IPresentationStep::GetFlightSpeedFactor ( ) {
    enum gviPresentationStepFlightSpeed _result;
    HRESULT _hr = get_FlightSpeedFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(915)
inline void IPresentationStep::PutFlightSpeedFactor ( enum gviPresentationStepFlightSpeed pVal ) {
    HRESULT _hr = put_FlightSpeedFactor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(916)
inline GUID IPresentationStep::GetId ( ) {
    GUID _result;
    HRESULT _hr = get_Id(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(917)
inline long IPresentationStep::GetIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(918)
inline void IPresentationStep::PutIndex ( long pVal ) {
    HRESULT _hr = put_Index(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(919)
inline VARIANT_BOOL IPresentationStep::GetKeyStep ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_KeyStep(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(920)
inline void IPresentationStep::PutKeyStep ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_KeyStep(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(921)
inline double IPresentationStep::GetLocationSplineSpeed ( ) {
    double _result = 0;
    HRESULT _hr = get_LocationSplineSpeed(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(922)
inline void IPresentationStep::PutLocationSplineSpeed ( double pVal ) {
    HRESULT _hr = put_LocationSplineSpeed(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(923)
inline enum gviPresentationSplineSpeedBehavior IPresentationStep::GetLocationSplineSpeedBehavior ( ) {
    enum gviPresentationSplineSpeedBehavior _result;
    HRESULT _hr = get_LocationSplineSpeedBehavior(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(924)
inline void IPresentationStep::PutLocationSplineSpeedBehavior ( enum gviPresentationSplineSpeedBehavior pVal ) {
    HRESULT _hr = put_LocationSplineSpeedBehavior(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(925)
inline enum gviPresentationStepType IPresentationStep::GetType ( ) {
    enum gviPresentationStepType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(926)
inline void IPresentationStep::PutType ( enum gviPresentationStepType pVal ) {
    HRESULT _hr = put_Type(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(927)
inline long IPresentationStep::GetWaitTime ( ) {
    long _result = 0;
    HRESULT _hr = get_WaitTime(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(928)
inline void IPresentationStep::PutWaitTime ( long pVal ) {
    HRESULT _hr = put_WaitTime(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(929)
inline VARIANT_BOOL IPresentationStep::GetShowHideValue ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowHideValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(930)
inline void IPresentationStep::PutShowHideValue ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowHideValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(931)
inline VARIANT_BOOL IPresentationStep::ContainsOperation ( _bstr_t OperationName ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ContainsOperation(OperationName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(932)
inline _bstr_t IPresentationStep::GetOperationValue ( _bstr_t OperationName ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetOperationValue(OperationName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IPresentationSteps wrapper method implementations
//

#pragma implementation_key(933)
inline long IPresentationSteps::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(934)
inline long IPresentationSteps::GetCurrent ( ) {
    long _result = 0;
    HRESULT _hr = get_Current(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(935)
inline IPresentationStepPtr IPresentationSteps::GetStep ( long Index ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = get_Step(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

//
// interface IPresentation wrapper method implementations
//

#pragma implementation_key(936)
inline long IPresentation::GetCaptionHeight ( ) {
    long _result = 0;
    HRESULT _hr = get_CaptionHeight(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(937)
inline void IPresentation::PutCaptionHeight ( long pVal ) {
    HRESULT _hr = put_CaptionHeight(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(938)
inline enum gviPresentationCaptionPosition IPresentation::GetCaptionPosition ( ) {
    enum gviPresentationCaptionPosition _result;
    HRESULT _hr = get_CaptionPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(939)
inline void IPresentation::PutCaptionPosition ( enum gviPresentationCaptionPosition pVal ) {
    HRESULT _hr = put_CaptionPosition(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(940)
inline enum gviPresentationCaptionSizeType IPresentation::GetCaptionSizeType ( ) {
    enum gviPresentationCaptionSizeType _result;
    HRESULT _hr = get_CaptionSizeType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(941)
inline void IPresentation::PutCaptionSizeType ( enum gviPresentationCaptionSizeType pVal ) {
    HRESULT _hr = put_CaptionSizeType(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(942)
inline long IPresentation::GetCaptionWidth ( ) {
    long _result = 0;
    HRESULT _hr = get_CaptionWidth(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(943)
inline void IPresentation::PutCaptionWidth ( long pVal ) {
    HRESULT _hr = put_CaptionWidth(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(944)
inline VARIANT_BOOL IPresentation::GetLoopRoute ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LoopRoute(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(945)
inline void IPresentation::PutLoopRoute ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LoopRoute(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(946)
inline enum gviPresentationPlayAlgorithm IPresentation::GetPlayAlgorithm ( ) {
    enum gviPresentationPlayAlgorithm _result;
    HRESULT _hr = get_PlayAlgorithm(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(947)
inline void IPresentation::PutPlayAlgorithm ( enum gviPresentationPlayAlgorithm pVal ) {
    HRESULT _hr = put_PlayAlgorithm(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(948)
inline enum gviPresentationPlayMode IPresentation::GetPlayMode ( ) {
    enum gviPresentationPlayMode _result;
    HRESULT _hr = get_PlayMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(949)
inline void IPresentation::PutPlayMode ( enum gviPresentationPlayMode pVal ) {
    HRESULT _hr = put_PlayMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(950)
inline enum gviPresentationPlaySpeed IPresentation::GetPlaySpeedFactor ( ) {
    enum gviPresentationPlaySpeed _result;
    HRESULT _hr = get_PlaySpeedFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(951)
inline void IPresentation::PutPlaySpeedFactor ( enum gviPresentationPlaySpeed pVal ) {
    HRESULT _hr = put_PlaySpeedFactor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(952)
inline enum gviPresentationStatus IPresentation::GetPresentationStatus ( ) {
    enum gviPresentationStatus _result;
    HRESULT _hr = get_PresentationStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(953)
inline IPresentationStepsPtr IPresentation::GetSteps ( ) {
    struct IPresentationSteps * _result = 0;
    HRESULT _hr = get_Steps(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepsPtr(_result, false);
}

#pragma implementation_key(954)
inline HRESULT IPresentation::Continue ( ) {
    HRESULT _hr = raw_Continue();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(955)
inline IPresentationStepPtr IPresentation::CreateCaptionStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, _bstr_t CaptionText, long CaptionTimeout, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateCaptionStep(AdvancedType, WaitTime, Description, CaptionText, CaptionTimeout, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(956)
inline IPresentationStepPtr IPresentation::CreateClearCaptionStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateClearCaptionStep(AdvancedType, WaitTime, Description, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(957)
inline IPresentationStepPtr IPresentation::CreateFlightSpeedFactorStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, enum gviPresentationStepFlightSpeed FlightSpeedFactor, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateFlightSpeedFactorStep(AdvancedType, WaitTime, Description, FlightSpeedFactor, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(958)
inline IPresentationStepPtr IPresentation::CreateFollowDynamicObjectStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, GUID ObjectId, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateFollowDynamicObjectStep(AdvancedType, WaitTime, Description, ObjectId, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(959)
inline IPresentationStepPtr IPresentation::CreateLocationStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, struct IPosition * Position, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateLocationStep(AdvancedType, WaitTime, Description, Position, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(960)
inline IPresentationStepPtr IPresentation::CreateRestartDynamicObjectStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, GUID ObjectId, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateRestartDynamicObjectStep(AdvancedType, WaitTime, Description, ObjectId, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(961)
inline IPresentationStepPtr IPresentation::CreateShowGroupStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, GUID GroupId, VARIANT_BOOL Show, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateShowGroupStep(AdvancedType, WaitTime, Description, GroupId, Show, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(962)
inline IPresentationStepPtr IPresentation::CreateShowObjectStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, GUID ObjectId, VARIANT_BOOL Show, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateShowObjectStep(AdvancedType, WaitTime, Description, ObjectId, Show, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(963)
inline IPresentationStepPtr IPresentation::CreateShowUndergroundModeStep ( enum gviPresentationStepContinue AdvancedType, long WaitTime, _bstr_t Description, VARIANT_BOOL Show, long InsertIndex ) {
    struct IPresentationStep * _result = 0;
    HRESULT _hr = raw_CreateShowUndergroundModeStep(AdvancedType, WaitTime, Description, Show, InsertIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationStepPtr(_result, false);
}

#pragma implementation_key(964)
inline HRESULT IPresentation::DeleteStep ( long Index ) {
    HRESULT _hr = raw_DeleteStep(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(965)
inline HRESULT IPresentation::MoveStepTo ( long FromIndex, long ToIndex ) {
    HRESULT _hr = raw_MoveStepTo(FromIndex, ToIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(966)
inline HRESULT IPresentation::NextStep ( ) {
    HRESULT _hr = raw_NextStep();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(967)
inline HRESULT IPresentation::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(968)
inline HRESULT IPresentation::Play ( long StartIndex ) {
    HRESULT _hr = raw_Play(StartIndex);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(969)
inline HRESULT IPresentation::PlayStep ( long Index ) {
    HRESULT _hr = raw_PlayStep(Index);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(970)
inline HRESULT IPresentation::PreviousStep ( ) {
    HRESULT _hr = raw_PreviousStep();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(971)
inline HRESULT IPresentation::ResetPresentation ( ) {
    HRESULT _hr = raw_ResetPresentation();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(972)
inline HRESULT IPresentation::Resume ( ) {
    HRESULT _hr = raw_Resume();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(973)
inline HRESULT IPresentation::StartRecord ( ) {
    HRESULT _hr = raw_StartRecord();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(974)
inline HRESULT IPresentation::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(975)
inline HRESULT IPresentation::StopRecord ( ) {
    HRESULT _hr = raw_StopRecord();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(976)
inline HRESULT IPresentation::ShowEditor ( ) {
    HRESULT _hr = raw_ShowEditor();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(977)
inline _bstr_t IPresentation::GetSlideImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SlideImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(978)
inline void IPresentation::PutSlideImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_SlideImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(979)
inline VARIANT_BOOL IPresentation::CreateMovie ( _bstr_t Name, long Width, long Height, double FPS ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CreateMovie(Name, Width, Height, FPS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(980)
inline HRESULT IPresentation::CancelExport ( ) {
    HRESULT _hr = raw_CancelExport();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IComplexParticleEffect wrapper method implementations
//

#pragma implementation_key(981)
inline HRESULT IComplexParticleEffect::Play ( ) {
    HRESULT _hr = raw_Play();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(982)
inline HRESULT IComplexParticleEffect::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(983)
inline IPointPtr IComplexParticleEffect::GetPosition ( ) {
    struct IPoint * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPointPtr(_result, false);
}

#pragma implementation_key(984)
inline void IComplexParticleEffect::PutPosition ( struct IPoint * pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(985)
inline IEulerAnglePtr IComplexParticleEffect::GetRotateAngle ( ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = get_RotateAngle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(986)
inline void IComplexParticleEffect::PutRotateAngle ( struct IEulerAngle * pVal ) {
    HRESULT _hr = put_RotateAngle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(987)
inline double IComplexParticleEffect::GetScalingFactor ( ) {
    double _result = 0;
    HRESULT _hr = get_ScalingFactor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(988)
inline void IComplexParticleEffect::PutScalingFactor ( double pVal ) {
    HRESULT _hr = put_ScalingFactor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(989)
inline double IComplexParticleEffect::GetEmissionRate ( ) {
    double _result = 0;
    HRESULT _hr = get_EmissionRate(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(990)
inline void IComplexParticleEffect::PutEmissionRate ( double pVal ) {
    HRESULT _hr = put_EmissionRate(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(991)
inline double IComplexParticleEffect::GetWindDirection ( ) {
    double _result = 0;
    HRESULT _hr = get_WindDirection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(992)
inline void IComplexParticleEffect::PutWindDirection ( double pVal ) {
    HRESULT _hr = put_WindDirection(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(993)
inline double IComplexParticleEffect::GetWindAcceleration ( ) {
    double _result = 0;
    HRESULT _hr = get_WindAcceleration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(994)
inline void IComplexParticleEffect::PutWindAcceleration ( double pVal ) {
    HRESULT _hr = put_WindAcceleration(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(995)
inline enum gviComplexParticleEffectType IComplexParticleEffect::GetComplexParticleEffectType ( ) {
    enum gviComplexParticleEffectType _result;
    HRESULT _hr = raw_GetComplexParticleEffectType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(996)
inline VARIANT_BOOL IComplexParticleEffect::GetIsAlive ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsAlive(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(997)
inline double IComplexParticleEffect::GetDuration ( ) {
    double _result = 0;
    HRESULT _hr = get_Duration(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IKmlGroup wrapper method implementations
//

#pragma implementation_key(998)
inline HRESULT IKmlGroup::SetVisibleMask ( enum gviViewportMask Mask ) {
    HRESULT _hr = raw_SetVisibleMask(Mask);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IHeatMap wrapper method implementations
//

#pragma implementation_key(999)
inline double IHeatMap::GetAttenRadius ( ) {
    double _result = 0;
    HRESULT _hr = get_AttenRadius(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1000)
inline void IHeatMap::PutAttenRadius ( double pVal ) {
    HRESULT _hr = put_AttenRadius(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1001)
inline double IHeatMap::GetMaxHeatValue ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxHeatValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1002)
inline void IHeatMap::PutMaxHeatValue ( double pVal ) {
    HRESULT _hr = put_MaxHeatValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1003)
inline double IHeatMap::GetMinHeatValue ( ) {
    double _result = 0;
    HRESULT _hr = get_MinHeatValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1004)
inline void IHeatMap::PutMinHeatValue ( double pVal ) {
    HRESULT _hr = put_MinHeatValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IOperation wrapper method implementations
//

#pragma implementation_key(1005)
inline HRESULT IOperation::Execute ( ) {
    HRESULT _hr = raw_Execute();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1006)
inline HRESULT IOperation::Cancel ( ) {
    HRESULT _hr = raw_Cancel();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IClipPlaneOperation wrapper method implementations
//

#pragma implementation_key(1007)
inline enum gviClipPlaneOperation IClipPlaneOperation::GetClipPlaneOperationType ( ) {
    enum gviClipPlaneOperation _result;
    HRESULT _hr = get_ClipPlaneOperationType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1008)
inline HRESULT IClipPlaneOperation::SetSingleClip ( struct IVector3 * Position, struct IEulerAngle * Angle ) {
    HRESULT _hr = raw_SetSingleClip(Position, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1009)
inline HRESULT IClipPlaneOperation::GetSingleClip ( struct IVector3 * * Position, struct IEulerAngle * * Angle ) {
    HRESULT _hr = raw_GetSingleClip(Position, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1010)
inline HRESULT IClipPlaneOperation::SetBoxClip ( struct IVector3 * BoxCenter, struct IVector3 * BoxSize, struct IEulerAngle * Angle ) {
    HRESULT _hr = raw_SetBoxClip(BoxCenter, BoxSize, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1011)
inline HRESULT IClipPlaneOperation::GetBoxClip ( struct IVector3 * * BoxCenter, struct IVector3 * * BoxSize, struct IEulerAngle * * Angle ) {
    HRESULT _hr = raw_GetBoxClip(BoxCenter, BoxSize, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IObjectManager wrapper method implementations
//

#pragma implementation_key(1012)
inline IFeatureLayerPtr IObjectManager::CreateFeatureLayer ( struct IFeatureClass * FeatureClass, _bstr_t GeoField, struct ITextRender * TextRender, struct IGeometryRender * GeoRender, GUID GroupId ) {
    struct IFeatureLayer * _result = 0;
    HRESULT _hr = raw_CreateFeatureLayer(FeatureClass, GeoField, TextRender, GeoRender, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFeatureLayerPtr(_result, false);
}

#pragma implementation_key(1013)
inline IFeatureLayerPtr IObjectManager::GetFeatureLayer ( GUID FeatureLayerGuid ) {
    struct IFeatureLayer * _result = 0;
    HRESULT _hr = raw_GetFeatureLayer(FeatureLayerGuid, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFeatureLayerPtr(_result, false);
}

#pragma implementation_key(1014)
inline ITerrainRoutePtr IObjectManager::CreateTerrainRoute ( GUID GroupId ) {
    struct ITerrainRoute * _result = 0;
    HRESULT _hr = raw_CreateTerrainRoute(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainRoutePtr(_result, false);
}

#pragma implementation_key(1015)
inline IRenderModelPointPtr IObjectManager::CreateRenderModelPoint ( struct IModelPoint * ModelPoint, struct IModelPointSymbol * Symbol, GUID GroupId ) {
    struct IRenderModelPoint * _result = 0;
    HRESULT _hr = raw_CreateRenderModelPoint(ModelPoint, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderModelPointPtr(_result, false);
}

#pragma implementation_key(1016)
inline IRenderPolylinePtr IObjectManager::CreateRenderPolyline ( struct IPolyline * Polyline, struct ICurveSymbol * Symbol, GUID GroupId ) {
    struct IRenderPolyline * _result = 0;
    HRESULT _hr = raw_CreateRenderPolyline(Polyline, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPolylinePtr(_result, false);
}

#pragma implementation_key(1017)
inline IRenderPolygonPtr IObjectManager::CreateRenderPolygon ( struct IPolygon * Polygon, struct ISurfaceSymbol * Symbol, GUID GroupId ) {
    struct IRenderPolygon * _result = 0;
    HRESULT _hr = raw_CreateRenderPolygon(Polygon, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPolygonPtr(_result, false);
}

#pragma implementation_key(1018)
inline IRenderTriMeshPtr IObjectManager::CreateRenderTriMesh ( struct ITriMesh * TriMesh, struct ISurfaceSymbol * Symbol, GUID GroupId ) {
    struct IRenderTriMesh * _result = 0;
    HRESULT _hr = raw_CreateRenderTriMesh(TriMesh, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderTriMeshPtr(_result, false);
}

#pragma implementation_key(1019)
inline IRenderMultiTriMeshPtr IObjectManager::CreateRenderMultiTriMesh ( struct IMultiTriMesh * MultiTriMesh, struct ISurfaceSymbol * Symbol, GUID GroupId ) {
    struct IRenderMultiTriMesh * _result = 0;
    HRESULT _hr = raw_CreateRenderMultiTriMesh(MultiTriMesh, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiTriMeshPtr(_result, false);
}

#pragma implementation_key(1020)
inline IRenderMultiPointPtr IObjectManager::CreateRenderMultiPoint ( struct IMultiPoint * MultiPoint, struct IPointSymbol * Symbol, GUID GroupId ) {
    struct IRenderMultiPoint * _result = 0;
    HRESULT _hr = raw_CreateRenderMultiPoint(MultiPoint, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiPointPtr(_result, false);
}

#pragma implementation_key(1021)
inline ICameraTourPtr IObjectManager::CreateCameraTour ( GUID GroupId ) {
    struct ICameraTour * _result = 0;
    HRESULT _hr = raw_CreateCameraTour(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICameraTourPtr(_result, false);
}

#pragma implementation_key(1022)
inline IRenderPointPtr IObjectManager::CreateRenderPoint ( struct IPoint * Point, struct IPointSymbol * Symbol, GUID GroupId ) {
    struct IRenderPoint * _result = 0;
    HRESULT _hr = raw_CreateRenderPoint(Point, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPointPtr(_result, false);
}

#pragma implementation_key(1023)
inline IMotionPathPtr IObjectManager::CreateMotionPath ( GUID GroupId ) {
    struct IMotionPath * _result = 0;
    HRESULT _hr = raw_CreateMotionPath(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IMotionPathPtr(_result, false);
}

#pragma implementation_key(1024)
inline IParticleEffectPtr IObjectManager::CreateParticleEffect ( GUID GroupId ) {
    struct IParticleEffect * _result = 0;
    HRESULT _hr = raw_CreateParticleEffect(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IParticleEffectPtr(_result, false);
}

#pragma implementation_key(1025)
inline ILabelPtr IObjectManager::CreateLabel ( GUID GroupId ) {
    struct ILabel * _result = 0;
    HRESULT _hr = raw_CreateLabel(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILabelPtr(_result, false);
}

#pragma implementation_key(1026)
inline IParticleEffectPtr IObjectManager::CreateParticleEffectFromFDB ( struct IFeatureDataSet * FeatureDataSet, GUID GroupId ) {
    struct IParticleEffect * _result = 0;
    HRESULT _hr = raw_CreateParticleEffectFromFDB(FeatureDataSet, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IParticleEffectPtr(_result, false);
}

#pragma implementation_key(1027)
inline ITableLabelPtr IObjectManager::CreateTableLabel ( long RowCount, long ColumnCount, GUID GroupId ) {
    struct ITableLabel * _result = 0;
    HRESULT _hr = raw_CreateTableLabel(RowCount, ColumnCount, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITableLabelPtr(_result, false);
}

#pragma implementation_key(1028)
inline ISkinnedMeshPtr IObjectManager::CreateSkinnedMesh ( struct IModelPoint * ModelPoint, GUID GroupId ) {
    struct ISkinnedMesh * _result = 0;
    HRESULT _hr = raw_CreateSkinnedMesh(ModelPoint, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISkinnedMeshPtr(_result, false);
}

#pragma implementation_key(1029)
inline IRenderMultiPolylinePtr IObjectManager::CreateRenderMultiPolyline ( struct IMultiPolyline * MultiPolyline, struct ICurveSymbol * Symbol, GUID GroupId ) {
    struct IRenderMultiPolyline * _result = 0;
    HRESULT _hr = raw_CreateRenderMultiPolyline(MultiPolyline, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiPolylinePtr(_result, false);
}

#pragma implementation_key(1030)
inline IRenderMultiPolygonPtr IObjectManager::CreateRenderMultiPolygon ( struct IMultiPolygon * MultiPolygon, struct ISurfaceSymbol * Symbol, GUID GroupId ) {
    struct IRenderMultiPolygon * _result = 0;
    HRESULT _hr = raw_CreateRenderMultiPolygon(MultiPolygon, Symbol, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiPolygonPtr(_result, false);
}

#pragma implementation_key(1031)
inline IRObjectPtr IObjectManager::GetObjectById ( GUID Id ) {
    struct IRObject * _result = 0;
    HRESULT _hr = raw_GetObjectById(Id, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRObjectPtr(_result, false);
}

#pragma implementation_key(1032)
inline VARIANT_BOOL IObjectManager::DeleteObject ( GUID Id ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DeleteObject(Id, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1033)
inline ISkyBoxPtr IObjectManager::GetSkyBox ( long ViewIndex ) {
    struct ISkyBox * _result = 0;
    HRESULT _hr = raw_GetSkyBox(ViewIndex, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISkyBoxPtr(_result, false);
}

#pragma implementation_key(1034)
inline IReferencePlanePtr IObjectManager::GetReferencePlane ( ) {
    struct IReferencePlane * _result = 0;
    HRESULT _hr = raw_GetReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IReferencePlanePtr(_result, false);
}

#pragma implementation_key(1035)
inline IProjectTreePtr IObjectManager::GetProjectTree ( ) {
    struct IProjectTree * _result = 0;
    HRESULT _hr = raw_GetProjectTree(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IProjectTreePtr(_result, false);
}

#pragma implementation_key(1036)
inline _bstr_t IObjectManager::OpenRasterSourceDialog ( enum gviRasterSourceType DataSourceType ) {
    BSTR _result = 0;
    HRESULT _hr = raw_OpenRasterSourceDialog(DataSourceType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1037)
inline IImageryLayerPtr IObjectManager::CreateImageryLayer ( _bstr_t ConnectionString, GUID GroupId ) {
    struct IImageryLayer * _result = 0;
    HRESULT _hr = raw_CreateImageryLayer(ConnectionString, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IImageryLayerPtr(_result, false);
}

#pragma implementation_key(1038)
inline VARIANT_BOOL IObjectManager::DelayDelete ( GUID Id, long DelayTime ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_DelayDelete(Id, DelayTime, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1039)
inline ITerrainHolePtr IObjectManager::CreateTerrainHole ( struct IPolygon * Polygon, GUID GroupId ) {
    struct ITerrainHole * _result = 0;
    HRESULT _hr = raw_CreateTerrainHole(Polygon, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainHolePtr(_result, false);
}

#pragma implementation_key(1040)
inline I3DTileHolePtr IObjectManager::Create3DTileHole ( struct IPolygon * Polygon, GUID GroupId ) {
    struct I3DTileHole * _result = 0;
    HRESULT _hr = raw_Create3DTileHole(Polygon, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return I3DTileHolePtr(_result, false);
}

#pragma implementation_key(1041)
inline I3DTileLayerPtr IObjectManager::Create3DTileLayer ( _bstr_t LayerInfo, _bstr_t Password, GUID GroupId ) {
    struct I3DTileLayer * _result = 0;
    HRESULT _hr = raw_Create3DTileLayer(LayerInfo, Password, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return I3DTileLayerPtr(_result, false);
}

#pragma implementation_key(1042)
inline IOverlayLabelPtr IObjectManager::CreateOverlayLabel ( GUID GroupId ) {
    struct IOverlayLabel * _result = 0;
    HRESULT _hr = raw_CreateOverlayLabel(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IOverlayLabelPtr(_result, false);
}

#pragma implementation_key(1043)
inline ITerrainVideoPtr IObjectManager::CreateTerrainVideo ( struct IPoint * Position, GUID GroupId ) {
    struct ITerrainVideo * _result = 0;
    HRESULT _hr = raw_CreateTerrainVideo(Position, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainVideoPtr(_result, false);
}

#pragma implementation_key(1044)
inline IViewshedPtr IObjectManager::CreateViewshed ( struct IPoint * Position, GUID GroupId ) {
    struct IViewshed * _result = 0;
    HRESULT _hr = raw_CreateViewshed(Position, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IViewshedPtr(_result, false);
}

#pragma implementation_key(1045)
inline IRenderArrowPtr IObjectManager::CreateRenderArrow ( GUID GroupId ) {
    struct IRenderArrow * _result = 0;
    HRESULT _hr = raw_CreateRenderArrow(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderArrowPtr(_result, false);
}

#pragma implementation_key(1046)
inline HRESULT IObjectManager::AddModel ( _bstr_t ModelName, struct IModel * newVal ) {
    HRESULT _hr = raw_AddModel(ModelName, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1047)
inline HRESULT IObjectManager::DeleteModel ( _bstr_t ModelName ) {
    HRESULT _hr = raw_DeleteModel(ModelName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1048)
inline HRESULT IObjectManager::AddImage ( _bstr_t ImageName, struct IImage * newVal ) {
    HRESULT _hr = raw_AddImage(ImageName, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1049)
inline HRESULT IObjectManager::DeleteImage ( _bstr_t ImageName ) {
    HRESULT _hr = raw_DeleteImage(ImageName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1050)
inline IDynamicObjectPtr IObjectManager::CreateDynamicObject ( GUID GroupId ) {
    struct IDynamicObject * _result = 0;
    HRESULT _hr = raw_CreateDynamicObject(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDynamicObjectPtr(_result, false);
}

#pragma implementation_key(1051)
inline ITerrainModifierPtr IObjectManager::CreateTerrainModifier ( struct IPolygon * Polygon, GUID GroupId ) {
    struct ITerrainModifier * _result = 0;
    HRESULT _hr = raw_CreateTerrainModifier(Polygon, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainModifierPtr(_result, false);
}

#pragma implementation_key(1052)
inline IRenderPOIPtr IObjectManager::CreateRenderPOI ( struct IPOI * POI ) {
    struct IRenderPOI * _result = 0;
    HRESULT _hr = raw_CreateRenderPOI(POI, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPOIPtr(_result, false);
}

#pragma implementation_key(1053)
inline IRenderPOIPtr IObjectManager::CreateRenderPOIFromFDB ( struct IPOI * POI, struct IFeatureDataSet * FeatureDataSet ) {
    struct IRenderPOI * _result = 0;
    HRESULT _hr = raw_CreateRenderPOIFromFDB(POI, FeatureDataSet, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPOIPtr(_result, false);
}

#pragma implementation_key(1054)
inline IWalkGroundPtr IObjectManager::CreateWalkGround ( struct IModelPoint * ModelPoint ) {
    struct IWalkGround * _result = 0;
    HRESULT _hr = raw_CreateWalkGround(ModelPoint, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IWalkGroundPtr(_result, false);
}

#pragma implementation_key(1055)
inline IWalkGroundPtr IObjectManager::CreateWalkGroundFromFDB ( struct IFeatureClass * FeatureClass, _bstr_t GeoField ) {
    struct IWalkGround * _result = 0;
    HRESULT _hr = raw_CreateWalkGroundFromFDB(FeatureClass, GeoField, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IWalkGroundPtr(_result, false);
}

#pragma implementation_key(1056)
inline IGeometryRenderPtr IObjectManager::CreateGeometryRenderFromXML ( _bstr_t XmlStringValue ) {
    struct IGeometryRender * _result = 0;
    HRESULT _hr = raw_CreateGeometryRenderFromXML(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryRenderPtr(_result, false);
}

#pragma implementation_key(1057)
inline ITextRenderPtr IObjectManager::CreateTextRenderFromXML ( _bstr_t XmlStringValue ) {
    struct ITextRender * _result = 0;
    HRESULT _hr = raw_CreateTextRenderFromXML(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextRenderPtr(_result, false);
}

#pragma implementation_key(1058)
inline IGeometrySymbolPtr IObjectManager::CreateGeometrySymbolFromXML ( _bstr_t XmlStringValue ) {
    struct IGeometrySymbol * _result = 0;
    HRESULT _hr = raw_CreateGeometrySymbolFromXML(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometrySymbolPtr(_result, false);
}

#pragma implementation_key(1059)
inline ITextSymbolPtr IObjectManager::CreateTextSymbolFromXML ( _bstr_t XmlStringValue ) {
    struct ITextSymbol * _result = 0;
    HRESULT _hr = raw_CreateTextSymbolFromXML(XmlStringValue, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextSymbolPtr(_result, false);
}

#pragma implementation_key(1060)
inline ITerrainRegularPolygonPtr IObjectManager::CreateCircle ( struct IPosition * Position, double Radius, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrainRegularPolygon * _result = 0;
    HRESULT _hr = raw_CreateCircle(Position, Radius, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainRegularPolygonPtr(_result, false);
}

#pragma implementation_key(1061)
inline ITerrainRegularPolygonPtr IObjectManager::CreateRegularPolygon ( struct IPosition * Position, double Radius, long NumOfSegments, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrainRegularPolygon * _result = 0;
    HRESULT _hr = raw_CreateRegularPolygon(Position, Radius, NumOfSegments, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainRegularPolygonPtr(_result, false);
}

#pragma implementation_key(1062)
inline ITerrain3DRegBasePtr IObjectManager::CreateCylinder ( struct IPosition * Position, double Radius, double ObjectHeight, OLE_COLOR LineColor, OLE_COLOR FillColor, long NumOfSegments, GUID GroupId ) {
    struct ITerrain3DRegBase * _result = 0;
    HRESULT _hr = raw_CreateCylinder(Position, Radius, ObjectHeight, LineColor, FillColor, NumOfSegments, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRegBasePtr(_result, false);
}

#pragma implementation_key(1063)
inline ITerrain3DRegBasePtr IObjectManager::CreateCone ( struct IPosition * Position, double Radius, double ObjectHeight, OLE_COLOR LineColor, OLE_COLOR FillColor, long NumOfSegments, GUID GroupId ) {
    struct ITerrain3DRegBase * _result = 0;
    HRESULT _hr = raw_CreateCone(Position, Radius, ObjectHeight, LineColor, FillColor, NumOfSegments, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRegBasePtr(_result, false);
}

#pragma implementation_key(1064)
inline ITerrainArrowPtr IObjectManager::CreateArrow ( struct IPosition * Position, double Length, long Style, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrainArrow * _result = 0;
    HRESULT _hr = raw_CreateArrow(Position, Length, Style, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainArrowPtr(_result, false);
}

#pragma implementation_key(1065)
inline ITerrain3DArrowPtr IObjectManager::Create3DArrow ( struct IPosition * Position, double Length, long Style, double ObjectHeight, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrain3DArrow * _result = 0;
    HRESULT _hr = raw_Create3DArrow(Position, Length, Style, ObjectHeight, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DArrowPtr(_result, false);
}

#pragma implementation_key(1066)
inline ITerrainRectanglePtr IObjectManager::CreateRectangle ( struct IPosition * Position, double ObjectWidth, double ObjectDepth, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrainRectangle * _result = 0;
    HRESULT _hr = raw_CreateRectangle(Position, ObjectWidth, ObjectDepth, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainRectanglePtr(_result, false);
}

#pragma implementation_key(1067)
inline ITerrain3DRectBasePtr IObjectManager::CreateBox ( struct IPosition * Position, double ObjectWidth, double ObjectDepth, double ObjectHeight, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrain3DRectBase * _result = 0;
    HRESULT _hr = raw_CreateBox(Position, ObjectWidth, ObjectDepth, ObjectHeight, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRectBasePtr(_result, false);
}

#pragma implementation_key(1068)
inline ITerrain3DRectBasePtr IObjectManager::CreatePyramid ( struct IPosition * Position, double ObjectWidth, double ObjectDepth, double ObjectHeight, OLE_COLOR LineColor, OLE_COLOR FillColor, GUID GroupId ) {
    struct ITerrain3DRectBase * _result = 0;
    HRESULT _hr = raw_CreatePyramid(Position, ObjectWidth, ObjectDepth, ObjectHeight, LineColor, FillColor, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRectBasePtr(_result, false);
}

#pragma implementation_key(1069)
inline ITerrainEllipsePtr IObjectManager::CreateEllipse ( struct IPosition * Position, double RadiusX, double RadiusY, OLE_COLOR LineColor, OLE_COLOR FillColor, long NumOfSegments, GUID GroupId ) {
    struct ITerrainEllipse * _result = 0;
    HRESULT _hr = raw_CreateEllipse(Position, RadiusX, RadiusY, LineColor, FillColor, NumOfSegments, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainEllipsePtr(_result, false);
}

#pragma implementation_key(1070)
inline ITerrainArcPtr IObjectManager::CreateArc ( struct IPosition * Position, double RadiusX, double RadiusY, double StartAngle, double EndAngle, OLE_COLOR LineColor, OLE_COLOR FillColor, long NumOfSegments, GUID GroupId ) {
    struct ITerrainArc * _result = 0;
    HRESULT _hr = raw_CreateArc(Position, RadiusX, RadiusY, StartAngle, EndAngle, LineColor, FillColor, NumOfSegments, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainArcPtr(_result, false);
}

#pragma implementation_key(1071)
inline ITerrainSpherePtr IObjectManager::CreateSphere ( struct IPosition * Position, double Radius, long Style, OLE_COLOR LineColor, OLE_COLOR FillColor, long SegmentDensity, GUID GroupId ) {
    struct ITerrainSphere * _result = 0;
    HRESULT _hr = raw_CreateSphere(Position, Radius, Style, LineColor, FillColor, SegmentDensity, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainSpherePtr(_result, false);
}

#pragma implementation_key(1072)
inline ITerrainLocationPtr IObjectManager::CreateLocation ( struct IPosition * Position, GUID GroupId ) {
    struct ITerrainLocation * _result = 0;
    HRESULT _hr = raw_CreateLocation(Position, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainLocationPtr(_result, false);
}

#pragma implementation_key(1073)
inline ITerrainImageLabelPtr IObjectManager::CreateImageLabel ( struct IPosition * Position, _bstr_t ImageFileName, struct ILabelStyle * Style, GUID GroupId ) {
    struct ITerrainImageLabel * _result = 0;
    HRESULT _hr = raw_CreateImageLabel(Position, ImageFileName, Style, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainImageLabelPtr(_result, false);
}

#pragma implementation_key(1074)
inline IPresentationPtr IObjectManager::CreatePresentation ( GUID GroupId ) {
    struct IPresentation * _result = 0;
    HRESULT _hr = raw_CreatePresentation(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IPresentationPtr(_result, false);
}

#pragma implementation_key(1075)
inline IComplexParticleEffectPtr IObjectManager::CreateComplexParticleEffect ( enum gviComplexParticleEffectType Type, GUID GroupId ) {
    struct IComplexParticleEffect * _result = 0;
    HRESULT _hr = raw_CreateComplexParticleEffect(Type, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IComplexParticleEffectPtr(_result, false);
}

#pragma implementation_key(1076)
inline IKmlGroupPtr IObjectManager::CreateKmlGroup ( _bstr_t File ) {
    struct IKmlGroup * _result = 0;
    HRESULT _hr = raw_CreateKmlGroup(File, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IKmlGroupPtr(_result, false);
}

#pragma implementation_key(1077)
inline IHeatMapPtr IObjectManager::CreateHeatMap ( struct IFeatureClass * FeatureClass, _bstr_t GeoFieldName, _bstr_t HeatValueFieldName, GUID GroupId ) {
    struct IHeatMap * _result = 0;
    HRESULT _hr = raw_CreateHeatMap(FeatureClass, GeoFieldName, HeatValueFieldName, GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IHeatMapPtr(_result, false);
}

#pragma implementation_key(1078)
inline IClipPlaneOperationPtr IObjectManager::CreateClipPlaneOperation ( GUID GroupId ) {
    struct IClipPlaneOperation * _result = 0;
    HRESULT _hr = raw_CreateClipPlaneOperation(GroupId, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IClipPlaneOperationPtr(_result, false);
}

//
// interface ICacheManager wrapper method implementations
//

#pragma implementation_key(1079)
inline VARIANT_BOOL ICacheManager::GetFileCacheEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FileCacheEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1080)
inline void ICacheManager::PutFileCacheEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FileCacheEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1081)
inline _bstr_t ICacheManager::GetFileCachePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FileCachePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1082)
inline void ICacheManager::PutFileCachePath ( _bstr_t pVal ) {
    HRESULT _hr = put_FileCachePath(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1083)
inline long ICacheManager::GetFileCacheSize ( ) {
    long _result = 0;
    HRESULT _hr = get_FileCacheSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1084)
inline void ICacheManager::PutFileCacheSize ( long pVal ) {
    HRESULT _hr = put_FileCacheSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1085)
inline VARIANT_BOOL ICacheManager::GetMemoryCacheEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MemoryCacheEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1086)
inline void ICacheManager::PutMemoryCacheEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MemoryCacheEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1087)
inline long ICacheManager::GetMemoryCacheSize ( ) {
    long _result = 0;
    HRESULT _hr = get_MemoryCacheSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1088)
inline void ICacheManager::PutMemoryCacheSize ( long pVal ) {
    HRESULT _hr = put_MemoryCacheSize(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1089)
inline _bstr_t ICacheManager::GetTileCacheFileName ( _bstr_t LayerInfo ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetTileCacheFileName(LayerInfo, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

//
// interface IRenderRule wrapper method implementations
//

#pragma implementation_key(1090)
inline _bstr_t IRenderRule::GetLookUpField ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_LookUpField(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1091)
inline void IRenderRule::PutLookUpField ( _bstr_t pVal ) {
    HRESULT _hr = put_LookUpField(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1092)
inline VARIANT_BOOL IRenderRule::GetOtherwise ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Otherwise(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1093)
inline void IRenderRule::PutOtherwise ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Otherwise(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1094)
inline enum gviRenderRuleType IRenderRule::GetRuleType ( ) {
    enum gviRenderRuleType _result;
    HRESULT _hr = get_RuleType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ITextRenderScheme wrapper method implementations
//

#pragma implementation_key(1095)
inline HRESULT ITextRenderScheme::AddRule ( struct IRenderRule * Rule ) {
    HRESULT _hr = raw_AddRule(Rule);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1096)
inline HRESULT ITextRenderScheme::ClearRules ( ) {
    HRESULT _hr = raw_ClearRules();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1097)
inline ITextSymbolPtr ITextRenderScheme::GetSymbol ( ) {
    struct ITextSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextSymbolPtr(_result, false);
}

#pragma implementation_key(1098)
inline void ITextRenderScheme::PutSymbol ( struct ITextSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1099)
inline IRenderRulePtr ITextRenderScheme::GetRule ( long Index ) {
    struct IRenderRule * _result = 0;
    HRESULT _hr = raw_GetRule(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderRulePtr(_result, false);
}

#pragma implementation_key(1100)
inline long ITextRenderScheme::GetRuleCount ( ) {
    long _result = 0;
    HRESULT _hr = get_RuleCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IGeometryRenderScheme wrapper method implementations
//

#pragma implementation_key(1101)
inline HRESULT IGeometryRenderScheme::AddRule ( struct IRenderRule * Rule ) {
    HRESULT _hr = raw_AddRule(Rule);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1102)
inline HRESULT IGeometryRenderScheme::ClearRules ( ) {
    HRESULT _hr = raw_ClearRules();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1103)
inline IGeometrySymbolPtr IGeometryRenderScheme::GetSymbol ( ) {
    struct IGeometrySymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometrySymbolPtr(_result, false);
}

#pragma implementation_key(1104)
inline void IGeometryRenderScheme::PutSymbol ( struct IGeometrySymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1105)
inline unsigned char IGeometryRenderScheme::GetVisibleMask ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_VisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1106)
inline void IGeometryRenderScheme::PutVisibleMask ( unsigned char pVal ) {
    HRESULT _hr = put_VisibleMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1107)
inline IRenderRulePtr IGeometryRenderScheme::GetRule ( long Index ) {
    struct IRenderRule * _result = 0;
    HRESULT _hr = raw_GetRule(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderRulePtr(_result, false);
}

#pragma implementation_key(1108)
inline long IGeometryRenderScheme::GetRuleCount ( ) {
    long _result = 0;
    HRESULT _hr = get_RuleCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IObjectEditor wrapper method implementations
//

#pragma implementation_key(1109)
inline VARIANT_BOOL IObjectEditor::StartEditFeatureGeometry ( struct IRowBuffer * RowBuffer, struct IFeatureLayer * FeatureLayer, enum gviGeoEditType EditType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StartEditFeatureGeometry(RowBuffer, FeatureLayer, EditType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1110)
inline VARIANT_BOOL IObjectEditor::StartEditRenderGeometry ( struct IRenderGeometry * RenderGeometry, enum gviGeoEditType EditType ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StartEditRenderGeometry(RenderGeometry, EditType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1111)
inline HRESULT IObjectEditor::FinishEdit ( ) {
    HRESULT _hr = raw_FinishEdit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1112)
inline HRESULT IObjectEditor::CancelEdit ( ) {
    HRESULT _hr = raw_CancelEdit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1113)
inline VARIANT_BOOL IObjectEditor::GetIsEditing ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsEditing(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1114)
inline HRESULT IObjectEditor::Move ( struct IVector3 * Move ) {
    HRESULT _hr = raw_Move(Move);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1115)
inline HRESULT IObjectEditor::Rotate ( struct IVector3 * Axis, struct IVector3 * Center, double Angle ) {
    HRESULT _hr = raw_Rotate(Axis, Center, Angle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1116)
inline HRESULT IObjectEditor::Scale ( struct IVector3 * Scale, struct IVector3 * Center ) {
    HRESULT _hr = raw_Scale(Scale, Center);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1117)
inline VARIANT_BOOL IObjectEditor::AddMovingFeatures ( struct IFeatureLayer * Layer, struct IRowBufferCollection * RowBuffers ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_AddMovingFeatures(Layer, RowBuffers, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1118)
inline VARIANT_BOOL IObjectEditor::StartMoveFeatures ( _bstr_t CRS ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StartMoveFeatures(CRS, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IViewport wrapper method implementations
//

#pragma implementation_key(1119)
inline VARIANT_BOOL IViewport::GetLogoVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LogoVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1120)
inline void IViewport::PutLogoVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_LogoVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1121)
inline VARIANT_BOOL IViewport::GetCameraInfoVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CameraInfoVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1122)
inline void IViewport::PutCameraInfoVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CameraInfoVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1123)
inline enum gviViewportMode IViewport::GetViewportMode ( ) {
    enum gviViewportMode _result;
    HRESULT _hr = get_ViewportMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1124)
inline void IViewport::PutViewportMode ( enum gviViewportMode pVal ) {
    HRESULT _hr = put_ViewportMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1125)
inline long IViewport::GetActiveView ( ) {
    long _result = 0;
    HRESULT _hr = get_ActiveView(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1126)
inline void IViewport::PutActiveView ( long pVal ) {
    HRESULT _hr = put_ActiveView(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1127)
inline enum gviViewportMask IViewport::GetCameraViewBindMask ( ) {
    enum gviViewportMask _result;
    HRESULT _hr = get_CameraViewBindMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1128)
inline void IViewport::PutCameraViewBindMask ( enum gviViewportMask pVal ) {
    HRESULT _hr = put_CameraViewBindMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1129)
inline enum gviViewportMask IViewport::GetCompassVisibleMask ( ) {
    enum gviViewportMask _result;
    HRESULT _hr = get_CompassVisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1130)
inline void IViewport::PutCompassVisibleMask ( enum gviViewportMask pVal ) {
    HRESULT _hr = put_CompassVisibleMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1131)
inline double IViewport::GetSplitRatioH ( ) {
    double _result = 0;
    HRESULT _hr = get_SplitRatioH(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1132)
inline void IViewport::PutSplitRatioH ( double pVal ) {
    HRESULT _hr = put_SplitRatioH(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1133)
inline double IViewport::GetSplitRatioV ( ) {
    double _result = 0;
    HRESULT _hr = get_SplitRatioV(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1134)
inline void IViewport::PutSplitRatioV ( double pVal ) {
    HRESULT _hr = put_SplitRatioV(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1135)
inline VARIANT_BOOL IViewport::GetShowBorderLine ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowBorderLine(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1136)
inline void IViewport::PutShowBorderLine ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowBorderLine(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IVisualAnalysis wrapper method implementations
//

#pragma implementation_key(1137)
inline HRESULT IVisualAnalysis::StartShadowAnalyse ( ) {
    HRESULT _hr = raw_StartShadowAnalyse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1138)
inline HRESULT IVisualAnalysis::StartViewshedAnalyse ( struct IPoint * Start, struct IPoint * End, double HorizontalAngle ) {
    HRESULT _hr = raw_StartViewshedAnalyse(Start, End, HorizontalAngle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1139)
inline HRESULT IVisualAnalysis::StopAnalyse ( ) {
    HRESULT _hr = raw_StopAnalyse();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1140)
inline HRESULT IVisualAnalysis::AddOccluder ( struct IFeatureLayer * FL, struct IGeometry * Geo ) {
    HRESULT _hr = raw_AddOccluder(FL, Geo);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1141)
inline HRESULT IVisualAnalysis::ClearOccluders ( ) {
    HRESULT _hr = raw_ClearOccluders();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IHighlightHelper wrapper method implementations
//

#pragma implementation_key(1142)
inline HRESULT IHighlightHelper::SetCircleRegion ( struct IPoint * Center, double Radius ) {
    HRESULT _hr = raw_SetCircleRegion(Center, Radius);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1143)
inline HRESULT IHighlightHelper::SetSectorRegion ( struct IPoint * Start, struct IPoint * End, double HorizontalAngle ) {
    HRESULT _hr = raw_SetSectorRegion(Start, End, HorizontalAngle);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1144)
inline IGeometryPtr IHighlightHelper::GetRegion ( ) {
    struct IGeometry * _result = 0;
    HRESULT _hr = raw_GetRegion(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryPtr(_result, false);
}

#pragma implementation_key(1145)
inline unsigned char IHighlightHelper::GetVisibleMask ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_VisibleMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1146)
inline void IHighlightHelper::PutVisibleMask ( unsigned char pVal ) {
    HRESULT _hr = put_VisibleMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1147)
inline double IHighlightHelper::GetMinZ ( ) {
    double _result = 0;
    HRESULT _hr = get_MinZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1148)
inline void IHighlightHelper::PutMinZ ( double pVal ) {
    HRESULT _hr = put_MinZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1149)
inline double IHighlightHelper::GetMaxZ ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxZ(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1150)
inline void IHighlightHelper::PutMaxZ ( double pVal ) {
    HRESULT _hr = put_MaxZ(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1151)
inline OLE_COLOR IHighlightHelper::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1152)
inline void IHighlightHelper::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1153)
inline HRESULT IHighlightHelper::SetRegion ( struct IGeometry * Geometry ) {
    HRESULT _hr = raw_SetRegion(Geometry);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ISunConfig wrapper method implementations
//

#pragma implementation_key(1154)
inline IEulerAnglePtr ISunConfig::GetSunEuler ( struct IPoint * Pos ) {
    struct IEulerAngle * _result = 0;
    HRESULT _hr = raw_GetSunEuler(Pos, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IEulerAnglePtr(_result, false);
}

#pragma implementation_key(1155)
inline HRESULT ISunConfig::SetSunEuler ( struct IEulerAngle * newVal ) {
    HRESULT _hr = raw_SetSunEuler(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1156)
inline enum gviSunCalculateMode ISunConfig::GetSunCalculateMode ( ) {
    enum gviSunCalculateMode _result;
    HRESULT _hr = get_SunCalculateMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1157)
inline void ISunConfig::PutSunCalculateMode ( enum gviSunCalculateMode pVal ) {
    HRESULT _hr = put_SunCalculateMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1158)
inline HRESULT ISunConfig::SetGMT ( DATE Time ) {
    HRESULT _hr = raw_SetGMT(Time);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1159)
inline OLE_COLOR ISunConfig::GetShadowColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_ShadowColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1160)
inline void ISunConfig::PutShadowColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_ShadowColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1161)
inline HRESULT ISunConfig::EnableShadow ( long ViewID, VARIANT_BOOL IsEnable ) {
    HRESULT _hr = raw_EnableShadow(ViewID, IsEnable);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1162)
inline VARIANT_BOOL ISunConfig::IsShadowEnabled ( long ViewID ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_IsShadowEnabled(ViewID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IPointCloudSymbol wrapper method implementations
//

#pragma implementation_key(1163)
inline OLE_COLOR IPointCloudSymbol::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1164)
inline void IPointCloudSymbol::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1165)
inline VARIANT_BOOL IPointCloudSymbol::GetEnableColor ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_EnableColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1166)
inline void IPointCloudSymbol::PutEnableColor ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_EnableColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1167)
inline long IPointCloudSymbol::GetSize ( ) {
    long _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1168)
inline void IPointCloudSymbol::PutSize ( long pVal ) {
    HRESULT _hr = put_Size(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRenderPOIPickResult wrapper method implementations
//

#pragma implementation_key(1169)
inline IRenderPOIPtr IRenderPOIPickResult::GetPOI ( ) {
    struct IRenderPOI * _result = 0;
    HRESULT _hr = get_POI(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPOIPtr(_result, false);
}

//
// interface IUtility wrapper method implementations
//

#pragma implementation_key(1170)
inline HRESULT IUtility::CreateFixedBillboard ( _bstr_t Text, struct ITextAttribute * TextAttribute, float Height, float Width, VARIANT_BOOL DoubleFace, struct IModel * * Model, struct IImage * * Image, BSTR * ImageName ) {
    HRESULT _hr = raw_CreateFixedBillboard(Text, TextAttribute, Height, Width, DoubleFace, Model, Image, ImageName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ITerrainVideoConfig wrapper method implementations
//

#pragma implementation_key(1171)
inline HRESULT ITerrainVideoConfig::SetPriorityDisplay ( struct ITerrainVideo * Video ) {
    HRESULT _hr = raw_SetPriorityDisplay(Video);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1172)
inline long ITerrainVideoConfig::GetMaxRealtimeTVNum ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxRealtimeTVNum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1173)
inline void ITerrainVideoConfig::PutMaxRealtimeTVNum ( long pVal ) {
    HRESULT _hr = put_MaxRealtimeTVNum(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1174)
inline long ITerrainVideoConfig::GetMaxVisualFieldTVNum ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxVisualFieldTVNum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1175)
inline void ITerrainVideoConfig::PutMaxVisualFieldTVNum ( long pVal ) {
    HRESULT _hr = put_MaxVisualFieldTVNum(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IProject wrapper method implementations
//

#pragma implementation_key(1176)
inline _bstr_t IProject::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1177)
inline HRESULT IProject::Open ( _bstr_t ProjectPath, VARIANT_BOOL Asynchronous, _bstr_t Password ) {
    HRESULT _hr = raw_Open(ProjectPath, Asynchronous, Password);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1178)
inline HRESULT IProject::Save ( ) {
    HRESULT _hr = raw_Save();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1179)
inline _bstr_t IProject::SaveAs ( _bstr_t ProjectFileName ) {
    BSTR _result = 0;
    HRESULT _hr = raw_SaveAs(ProjectFileName, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1180)
inline VARIANT_BOOL IProject::Close ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Close(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1181)
inline HRESULT IProject::PackReplaceConnectionString ( _bstr_t OldString, _bstr_t NewString ) {
    HRESULT _hr = raw_PackReplaceConnectionString(OldString, NewString);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1182)
inline VARIANT_BOOL IProject::PackGetInfo ( _bstr_t Path, VARIANT_BOOL IgnoreBigDataFile, unsigned __int64 * DiskFreeSize, unsigned __int64 * ResTotalSize, unsigned long * ResFileNumber ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_PackGetInfo(Path, IgnoreBigDataFile, DiskFreeSize, ResTotalSize, ResFileNumber, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1183)
inline VARIANT_BOOL IProject::PackResFile ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_PackResFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1184)
inline VARIANT_BOOL IProject::GetNeedSave ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NeedSave(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IHeatMapPlayer wrapper method implementations
//

#pragma implementation_key(1185)
inline double IHeatMapPlayer::GetAlpha ( ) {
    double _result = 0;
    HRESULT _hr = get_Alpha(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1186)
inline void IHeatMapPlayer::PutAlpha ( double pVal ) {
    HRESULT _hr = put_Alpha(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1187)
inline VARIANT_BOOL IHeatMapPlayer::StartPlay ( DATE StartTime, DATE EndTime, double Duration ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_StartPlay(StartTime, EndTime, Duration, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1188)
inline VARIANT_BOOL IHeatMapPlayer::SetTime ( DATE CurTime ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_SetTime(CurTime, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1189)
inline HRESULT IHeatMapPlayer::Pause ( ) {
    HRESULT _hr = raw_Pause();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1190)
inline HRESULT IHeatMapPlayer::Continue ( ) {
    HRESULT _hr = raw_Continue();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1191)
inline HRESULT IHeatMapPlayer::Stop ( ) {
    HRESULT _hr = raw_Stop();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IUIRect wrapper method implementations
//

#pragma implementation_key(1192)
inline HRESULT IUIRect::Init ( double LeftScale, double LeftOffset, double TopScale, double TopOffset, double RightScale, double RightOffset, double BottomScale, double BottomOffset ) {
    HRESULT _hr = raw_Init(LeftScale, LeftOffset, TopScale, TopOffset, RightScale, RightOffset, BottomScale, BottomOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IUIWindow wrapper method implementations
//

#pragma implementation_key(1193)
inline _bstr_t IUIWindow::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1194)
inline void IUIWindow::PutName ( _bstr_t pVal ) {
    HRESULT _hr = put_Name(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1195)
inline _bstr_t IUIWindow::GetText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Text(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1196)
inline void IUIWindow::PutText ( _bstr_t pVal ) {
    HRESULT _hr = put_Text(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1197)
inline VARIANT_BOOL IUIWindow::GetIsVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1198)
inline void IUIWindow::PutIsVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_IsVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1199)
inline VARIANT_BOOL IUIWindow::GetIsDisabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsDisabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1200)
inline void IUIWindow::PutIsDisabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_IsDisabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1201)
inline enum gviUIWindowType IUIWindow::GetType ( ) {
    enum gviUIWindowType _result;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1202)
inline HRESULT IUIWindow::SetArea ( struct IUIRect * newVal ) {
    HRESULT _hr = raw_SetArea(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1203)
inline HRESULT IUIWindow::SubscribeEvent ( enum gviUIEventType eventType ) {
    HRESULT _hr = raw_SubscribeEvent(eventType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1204)
inline HRESULT IUIWindow::UnsubscribeEvent ( enum gviUIEventType eventType ) {
    HRESULT _hr = raw_UnsubscribeEvent(eventType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IUIImageButton wrapper method implementations
//

#pragma implementation_key(1205)
inline void IUIImageButton::PutNormalImage ( _bstr_t _arg1 ) {
    HRESULT _hr = put_NormalImage(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1206)
inline void IUIImageButton::PutHoverImage ( _bstr_t _arg1 ) {
    HRESULT _hr = put_HoverImage(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1207)
inline void IUIImageButton::PutPushedImage ( _bstr_t _arg1 ) {
    HRESULT _hr = put_PushedImage(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1208)
inline void IUIImageButton::PutDisabledImage ( _bstr_t _arg1 ) {
    HRESULT _hr = put_DisabledImage(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IUIWindowManager wrapper method implementations
//

#pragma implementation_key(1209)
inline IUIImageButtonPtr IUIWindowManager::CreateImageButton ( ) {
    struct IUIImageButton * _result = 0;
    HRESULT _hr = raw_CreateImageButton(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUIImageButtonPtr(_result, false);
}

//
// dispinterface _IRenderControlEvents wrapper method implementations
//

#pragma implementation_key(1210)
inline VARIANT_BOOL _IRenderControlEvents::RcLButtonDown ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x1, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1211)
inline VARIANT_BOOL _IRenderControlEvents::RcLButtonUp ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x2, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1212)
inline VARIANT_BOOL _IRenderControlEvents::RcLButtonDblClk ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x3, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1213)
inline VARIANT_BOOL _IRenderControlEvents::RcMButtonDown ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x4, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1214)
inline VARIANT_BOOL _IRenderControlEvents::RcMButtonUp ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x5, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1215)
inline VARIANT_BOOL _IRenderControlEvents::RcMButtonDblClk ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x6, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1216)
inline VARIANT_BOOL _IRenderControlEvents::RcRButtonDown ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x7, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1217)
inline VARIANT_BOOL _IRenderControlEvents::RcRButtonUp ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x8, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1218)
inline VARIANT_BOOL _IRenderControlEvents::RcRButtonDblClk ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x9, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1219)
inline VARIANT_BOOL _IRenderControlEvents::RcMouseMove ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0xa, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1220)
inline VARIANT_BOOL _IRenderControlEvents::RcMouseHover ( unsigned long Flags, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0xb, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003\x0003", Flags, X, Y);
    return _result;
}

#pragma implementation_key(1221)
inline VARIANT_BOOL _IRenderControlEvents::RcMouseWheel ( unsigned long Flags, short Delta, long X, long Y ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0xc, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0002\x0003\x0003", Flags, Delta, X, Y);
    return _result;
}

#pragma implementation_key(1222)
inline VARIANT_BOOL _IRenderControlEvents::RcChar ( unsigned long Flags, unsigned long Char ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0xd, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003", Flags, Char);
    return _result;
}

#pragma implementation_key(1223)
inline VARIANT_BOOL _IRenderControlEvents::RcKeyDown ( unsigned long Flags, unsigned long Char ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0xe, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003", Flags, Char);
    return _result;
}

#pragma implementation_key(1224)
inline VARIANT_BOOL _IRenderControlEvents::RcKeyUp ( unsigned long Flags, unsigned long Char ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0xf, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003", Flags, Char);
    return _result;
}

#pragma implementation_key(1225)
inline HRESULT _IRenderControlEvents::RcDragEnter ( IUnknown * DataObject, unsigned long KeyState, long X, long Y, unsigned long * Effect ) {
    return _com_dispatch_method(this, 0x10, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000d\x0003\x0003\x0003\x4003", DataObject, KeyState, X, Y, Effect);
}

#pragma implementation_key(1226)
inline HRESULT _IRenderControlEvents::RcDragOver ( unsigned long KeyState, long X, long Y, unsigned long Effect ) {
    return _com_dispatch_method(this, 0x11, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003\x0003\x0003", KeyState, X, Y, Effect);
}

#pragma implementation_key(1227)
inline HRESULT _IRenderControlEvents::RcDragLeave ( ) {
    return _com_dispatch_method(this, 0x12, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1228)
inline HRESULT _IRenderControlEvents::RcDrop ( IUnknown * DataObject, unsigned long KeyState, long X, long Y, unsigned long * Effect ) {
    return _com_dispatch_method(this, 0x13, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x000d\x0003\x0003\x0003\x4003", DataObject, KeyState, X, Y, Effect);
}

#pragma implementation_key(1229)
inline HRESULT _IRenderControlEvents::RcMouseClickSelect ( struct IPickResult * PickResult, struct IPoint * IntersectPoint, enum gviModKeyMask Mask, enum gviMouseSelectMode EventSender ) {
    return _com_dispatch_method(this, 0x14, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009\x0003\x0003", PickResult, IntersectPoint, Mask, EventSender);
}

#pragma implementation_key(1230)
inline HRESULT _IRenderControlEvents::RcMouseDragSelect ( struct IPickResultCollection * PickResults, enum gviModKeyMask Mask ) {
    return _com_dispatch_method(this, 0x15, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003", PickResults, Mask);
}

#pragma implementation_key(1231)
inline HRESULT _IRenderControlEvents::RcPictureExportBegin ( long NumberOfWidth, long NumberOfHeight ) {
    return _com_dispatch_method(this, 0x16, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0003", NumberOfWidth, NumberOfHeight);
}

#pragma implementation_key(1232)
inline HRESULT _IRenderControlEvents::RcPictureExporting ( long Index, float Percentage ) {
    return _com_dispatch_method(this, 0x17, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003\x0004", Index, Percentage);
}

#pragma implementation_key(1233)
inline HRESULT _IRenderControlEvents::RcPictureExportEnd ( double Time, VARIANT_BOOL IsAborted ) {
    return _com_dispatch_method(this, 0x18, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0005\x000b", Time, IsAborted);
}

#pragma implementation_key(1234)
inline HRESULT _IRenderControlEvents::RcCameraFlyFinished ( unsigned char Type ) {
    return _com_dispatch_method(this, 0x19, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0011", Type);
}

#pragma implementation_key(1235)
inline HRESULT _IRenderControlEvents::RcCameraTourWaypointChanged ( long Index ) {
    return _com_dispatch_method(this, 0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0003", Index);
}

#pragma implementation_key(1236)
inline HRESULT _IRenderControlEvents::RcVideoExportBegin ( double TotalTime ) {
    return _com_dispatch_method(this, 0x1b, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0005", TotalTime);
}

#pragma implementation_key(1237)
inline HRESULT _IRenderControlEvents::RcVideoExporting ( float Percentage ) {
    return _com_dispatch_method(this, 0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0004", Percentage);
}

#pragma implementation_key(1238)
inline HRESULT _IRenderControlEvents::RcVideoExportEnd ( double Time, VARIANT_BOOL IsAborted ) {
    return _com_dispatch_method(this, 0x1d, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0005\x000b", Time, IsAborted);
}

#pragma implementation_key(1239)
inline HRESULT _IRenderControlEvents::RcDataSourceDisconnected ( _bstr_t DataSourceGuid, _bstr_t ConnectionInfo ) {
    return _com_dispatch_method(this, 0x1e, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x0008", (BSTR)DataSourceGuid, (BSTR)ConnectionInfo);
}

#pragma implementation_key(1240)
inline HRESULT _IRenderControlEvents::RcObjectEditing ( struct IGeometry * Geometry ) {
    return _com_dispatch_method(this, 0x28, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Geometry);
}

#pragma implementation_key(1241)
inline HRESULT _IRenderControlEvents::RcObjectEditFinish ( ) {
    return _com_dispatch_method(this, 0x29, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1242)
inline HRESULT _IRenderControlEvents::RcTransformHelperBegin ( ) {
    return _com_dispatch_method(this, 0x33, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1243)
inline HRESULT _IRenderControlEvents::RcTransformHelperEnd ( ) {
    return _com_dispatch_method(this, 0x34, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1244)
inline HRESULT _IRenderControlEvents::RcTransformHelperMoving ( struct IVector3 * Position ) {
    return _com_dispatch_method(this, 0x35, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Position);
}

#pragma implementation_key(1245)
inline HRESULT _IRenderControlEvents::RcTransformHelperRotating ( struct IVector3 * Axis, double Angle ) {
    return _com_dispatch_method(this, 0x36, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0005", Axis, Angle);
}

#pragma implementation_key(1246)
inline HRESULT _IRenderControlEvents::RcTransformHelperScaling ( struct IVector3 * Scale ) {
    return _com_dispatch_method(this, 0x37, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Scale);
}

#pragma implementation_key(1247)
inline HRESULT _IRenderControlEvents::RcTransformHelperBoxScaling ( struct IVector3 * Center, struct IVector3 * Scale ) {
    return _com_dispatch_method(this, 0x39, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0009", Center, Scale);
}

#pragma implementation_key(1248)
inline HRESULT _IRenderControlEvents::RcFeaturesMoving ( struct IVector3 * Translate ) {
    return _com_dispatch_method(this, 0x38, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009", Translate);
}

#pragma implementation_key(1249)
inline HRESULT _IRenderControlEvents::RcCameraUndoRedoStatusChanged ( ) {
    return _com_dispatch_method(this, 0x46, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

#pragma implementation_key(1250)
inline VARIANT_BOOL _IRenderControlEvents::RcResPacking ( long TotalResNo, long CurResIndex ) {
    VARIANT_BOOL _result = 0;
    _com_dispatch_method(this, 0x50, DISPATCH_METHOD, VT_BOOL, (void*)&_result, 
        L"\x0003\x0003", TotalResNo, CurResIndex);
    return _result;
}

#pragma implementation_key(1251)
inline HRESULT _IRenderControlEvents::RcBeforePresentationItemActivation ( _bstr_t PresentationID, struct IPresentationStep * Step ) {
    return _com_dispatch_method(this, 0x5a, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x0009", (BSTR)PresentationID, Step);
}

#pragma implementation_key(1252)
inline HRESULT _IRenderControlEvents::RcPresentationFlyToReachedDestination ( _bstr_t PresentationID, struct IPresentationStep * Step ) {
    return _com_dispatch_method(this, 0x5b, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x0009", (BSTR)PresentationID, Step);
}

#pragma implementation_key(1253)
inline HRESULT _IRenderControlEvents::RcPresentationStatusChanged ( _bstr_t PresentationID, enum gviPresentationStatus Status ) {
    return _com_dispatch_method(this, 0x5c, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0008\x0003", (BSTR)PresentationID, Status);
}

#pragma implementation_key(1254)
inline HRESULT _IRenderControlEvents::RcUIWindowEvent ( struct IUIEventArgs * EventArgs, enum gviUIEventType eventType ) {
    return _com_dispatch_method(this, 0x64, DISPATCH_METHOD, VT_EMPTY, NULL, 
        L"\x0009\x0003", EventArgs, eventType);
}

#pragma implementation_key(1255)
inline HRESULT _IRenderControlEvents::RcProjectChanged ( ) {
    return _com_dispatch_method(this, 0x51, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

//
// interface IExportManager wrapper method implementations
//

#pragma implementation_key(1256)
inline VARIANT_BOOL IExportManager::ExportImage ( _bstr_t FilePath, unsigned long Width, unsigned long Height, VARIANT_BOOL HighQuality ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportImage(FilePath, Width, Height, HighQuality, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1257)
inline VARIANT_BOOL IExportManager::ExportOrthoImage ( _bstr_t FilePath, unsigned long Width, struct IPoint * Center, struct IEulerAngle * Angle, struct IEnvelope * OrthoBox, VARIANT_BOOL HighQuality, OLE_COLOR BackgroundColor ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportOrthoImage(FilePath, Width, Center, Angle, OrthoBox, HighQuality, BackgroundColor, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1258)
inline HRESULT IExportManager::CancelExport ( ) {
    HRESULT _hr = raw_CancelExport();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1259)
inline VARIANT_BOOL IExportManager::ExportDOM ( _bstr_t FilePath, struct IEnvelope * Box, float MeterPerPixel ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportDOM(FilePath, Box, MeterPerPixel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1260)
inline VARIANT_BOOL IExportManager::ExportDEM ( _bstr_t FilePath, struct IEnvelope * Box, float MeterPerPixel ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportDEM(FilePath, Box, MeterPerPixel, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1261)
inline VARIANT_BOOL IExportManager::Export25D ( _bstr_t FilePath, struct IEnvelope * Box, float MeterPerPixel, struct IEulerAngle * Angle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Export25D(FilePath, Box, MeterPerPixel, Angle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1262)
inline VARIANT_BOOL IExportManager::Export25DEx ( _bstr_t FilePath, struct IEnvelope * Box, float MeterPerPixel, struct IEulerAngle * Angle, SAFEARRAY * FeatureClassIds, VARIANT_BOOL ExportShpOnly ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Export25DEx(FilePath, Box, MeterPerPixel, Angle, FeatureClassIds, ExportShpOnly, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1263)
inline VARIANT_BOOL IExportManager::ExportPanorama ( _bstr_t FilePath, unsigned long Width, struct IPoint * Center, struct IEulerAngle * Angle ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_ExportPanorama(FilePath, Width, Center, Angle, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IRenderControl wrapper method implementations
//

#pragma implementation_key(1264)
inline VARIANT_BOOL IRenderControl::Initialize ( VARIANT_BOOL IsPlanarTerrain, struct IPropertySet * Params ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Initialize(IsPlanarTerrain, Params, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1265)
inline HRESULT IRenderControl::RefreshModel ( struct IFeatureDataSet * DataSet, _bstr_t ModelName ) {
    HRESULT _hr = raw_RefreshModel(DataSet, ModelName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1266)
inline HRESULT IRenderControl::RefreshImage ( struct IFeatureDataSet * DataSet, _bstr_t ImageName ) {
    HRESULT _hr = raw_RefreshImage(DataSet, ImageName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1267)
inline void IRenderControl::PutOnFrameInvoke ( IDispatch * _arg1 ) {
    HRESULT _hr = put_OnFrameInvoke(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1268)
inline enum gviInteractMode IRenderControl::GetInteractMode ( ) {
    enum gviInteractMode _result;
    HRESULT _hr = get_InteractMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1269)
inline void IRenderControl::PutInteractMode ( enum gviInteractMode pVal ) {
    HRESULT _hr = put_InteractMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1270)
inline enum gviMouseSelectMode IRenderControl::GetMouseSelectMode ( ) {
    enum gviMouseSelectMode _result;
    HRESULT _hr = get_MouseSelectMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1271)
inline void IRenderControl::PutMouseSelectMode ( enum gviMouseSelectMode pVal ) {
    HRESULT _hr = put_MouseSelectMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1272)
inline enum gviMouseSelectObjectMask IRenderControl::GetMouseSelectObjectMask ( ) {
    enum gviMouseSelectObjectMask _result;
    HRESULT _hr = get_MouseSelectObjectMask(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1273)
inline void IRenderControl::PutMouseSelectObjectMask ( enum gviMouseSelectObjectMask pVal ) {
    HRESULT _hr = put_MouseSelectObjectMask(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1274)
inline VARIANT_BOOL IRenderControl::GetFullScreen ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_FullScreen(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1275)
inline void IRenderControl::PutFullScreen ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_FullScreen(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1276)
inline ITransformHelperPtr IRenderControl::GetTransformHelper ( ) {
    struct ITransformHelper * _result = 0;
    HRESULT _hr = get_TransformHelper(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITransformHelperPtr(_result, false);
}

#pragma implementation_key(1277)
inline IObjectEditorPtr IRenderControl::GetObjectEditor ( ) {
    struct IObjectEditor * _result = 0;
    HRESULT _hr = get_ObjectEditor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IObjectEditorPtr(_result, false);
}

#pragma implementation_key(1278)
inline ICameraPtr IRenderControl::GetCamera ( ) {
    struct ICamera * _result = 0;
    HRESULT _hr = get_Camera(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICameraPtr(_result, false);
}

#pragma implementation_key(1279)
inline ITerrainPtr IRenderControl::GetTerrain ( ) {
    struct ITerrain * _result = 0;
    HRESULT _hr = get_Terrain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainPtr(_result, false);
}

#pragma implementation_key(1280)
inline IFeatureManagerPtr IRenderControl::GetFeatureManager ( ) {
    struct IFeatureManager * _result = 0;
    HRESULT _hr = get_FeatureManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFeatureManagerPtr(_result, false);
}

#pragma implementation_key(1281)
inline IObjectManagerPtr IRenderControl::GetObjectManager ( ) {
    struct IObjectManager * _result = 0;
    HRESULT _hr = get_ObjectManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IObjectManagerPtr(_result, false);
}

#pragma implementation_key(1282)
inline ICacheManagerPtr IRenderControl::GetCacheManager ( ) {
    struct ICacheManager * _result = 0;
    HRESULT _hr = get_CacheManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICacheManagerPtr(_result, false);
}

#pragma implementation_key(1283)
inline IExportManagerPtr IRenderControl::GetExportManager ( ) {
    struct IExportManager * _result = 0;
    HRESULT _hr = get_ExportManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IExportManagerPtr(_result, false);
}

#pragma implementation_key(1284)
inline HRESULT IRenderControl::Reconnect ( ) {
    HRESULT _hr = raw_Reconnect();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1285)
inline IViewportPtr IRenderControl::GetViewport ( ) {
    struct IViewport * _result = 0;
    HRESULT _hr = get_Viewport(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IViewportPtr(_result, false);
}

#pragma implementation_key(1286)
inline HRESULT IRenderControl::Reset ( VARIANT_BOOL IsPlanarTerrain ) {
    HRESULT _hr = raw_Reset(IsPlanarTerrain);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1287)
inline _bstr_t IRenderControl::GetMouseCursor ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_MouseCursor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1288)
inline void IRenderControl::PutMouseCursor ( _bstr_t pVal ) {
    HRESULT _hr = put_MouseCursor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1289)
inline enum gviMeasurementMode IRenderControl::GetMeasurementMode ( ) {
    enum gviMeasurementMode _result;
    HRESULT _hr = get_MeasurementMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1290)
inline void IRenderControl::PutMeasurementMode ( enum gviMeasurementMode pVal ) {
    HRESULT _hr = put_MeasurementMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1291)
inline enum gviClipMode IRenderControl::GetClipMode ( ) {
    enum gviClipMode _result;
    HRESULT _hr = get_ClipMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1292)
inline void IRenderControl::PutClipMode ( enum gviClipMode pVal ) {
    HRESULT _hr = put_ClipMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1293)
inline IVisualAnalysisPtr IRenderControl::GetVisualAnalysis ( ) {
    struct IVisualAnalysis * _result = 0;
    HRESULT _hr = get_VisualAnalysis(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IVisualAnalysisPtr(_result, false);
}

#pragma implementation_key(1294)
inline IHighlightHelperPtr IRenderControl::GetHighlightHelper ( ) {
    struct IHighlightHelper * _result = 0;
    HRESULT _hr = get_HighlightHelper(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IHighlightHelperPtr(_result, false);
}

#pragma implementation_key(1295)
inline HRESULT IRenderControl::PauseRendering ( VARIANT_BOOL DumpMemory ) {
    HRESULT _hr = raw_PauseRendering(DumpMemory);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1296)
inline HRESULT IRenderControl::ResumeRendering ( ) {
    HRESULT _hr = raw_ResumeRendering();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1297)
inline long IRenderControl::GetLastError ( ) {
    long _result = 0;
    HRESULT _hr = raw_GetLastError(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1298)
inline VARIANT_BOOL IRenderControl::GetIsFocus ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsFocus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1299)
inline _bstr_t IRenderControl::GetTerrainCrsWKT ( _bstr_t LayerInfo, _bstr_t Password ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetTerrainCrsWKT(LayerInfo, Password, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1300)
inline VARIANT_BOOL IRenderControl::Initialize2 ( _bstr_t CrsWKT, struct IPropertySet * Params ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_Initialize2(CrsWKT, Params, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1301)
inline HRESULT IRenderControl::Reset2 ( _bstr_t CrsWKT ) {
    HRESULT _hr = raw_Reset2(CrsWKT);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1302)
inline _bstr_t IRenderControl::GetCurrentCrsWKT ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetCurrentCrsWKT(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1303)
inline ISunConfigPtr IRenderControl::GetSunConfig ( ) {
    struct ISunConfig * _result = 0;
    HRESULT _hr = get_SunConfig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISunConfigPtr(_result, false);
}

#pragma implementation_key(1304)
inline enum gviMouseSnapMode IRenderControl::GetMouseSnapMode ( ) {
    enum gviMouseSnapMode _result;
    HRESULT _hr = get_MouseSnapMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1305)
inline void IRenderControl::PutMouseSnapMode ( enum gviMouseSnapMode pVal ) {
    HRESULT _hr = put_MouseSnapMode(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1306)
inline HRESULT IRenderControl::SetRenderParam ( enum gviRenderControlParameters Param, const _variant_t & newVal ) {
    HRESULT _hr = raw_SetRenderParam(Param, newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1307)
inline _variant_t IRenderControl::GetRenderParam ( enum gviRenderControlParameters Param ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetRenderParam(Param, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

#pragma implementation_key(1308)
inline enum gviManipulatorMode IRenderControl::GetUseEarthOrbitManipulator ( ) {
    enum gviManipulatorMode _result;
    HRESULT _hr = get_UseEarthOrbitManipulator(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1309)
inline void IRenderControl::PutUseEarthOrbitManipulator ( enum gviManipulatorMode pVal ) {
    HRESULT _hr = put_UseEarthOrbitManipulator(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1310)
inline IUtilityPtr IRenderControl::GetUtility ( ) {
    struct IUtility * _result = 0;
    HRESULT _hr = get_Utility(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUtilityPtr(_result, false);
}

#pragma implementation_key(1311)
inline ITerrainVideoConfigPtr IRenderControl::GetTerrainVideoConfig ( ) {
    struct ITerrainVideoConfig * _result = 0;
    HRESULT _hr = get_TerrainVideoConfig(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainVideoConfigPtr(_result, false);
}

#pragma implementation_key(1312)
inline IProjectPtr IRenderControl::GetProject ( ) {
    struct IProject * _result = 0;
    HRESULT _hr = get_Project(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IProjectPtr(_result, false);
}

#pragma implementation_key(1313)
inline IProjectTreePtr IRenderControl::GetProjectTree ( ) {
    struct IProjectTree * _result = 0;
    HRESULT _hr = get_ProjectTree(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IProjectTreePtr(_result, false);
}

#pragma implementation_key(1314)
inline IHeatMapPlayerPtr IRenderControl::GetHeatMapPlayer ( ) {
    struct IHeatMapPlayer * _result = 0;
    HRESULT _hr = get_HeatMapPlayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IHeatMapPlayerPtr(_result, false);
}

#pragma implementation_key(1315)
inline IUIWindowManagerPtr IRenderControl::GetUIWindowManager ( ) {
    struct IUIWindowManager * _result = 0;
    HRESULT _hr = get_UIWindowManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUIWindowManagerPtr(_result, false);
}

//
// interface IFeatureLayerPickResult wrapper method implementations
//

#pragma implementation_key(1316)
inline IFeatureLayerPtr IFeatureLayerPickResult::GetFeatureLayer ( ) {
    struct IFeatureLayer * _result = 0;
    HRESULT _hr = get_FeatureLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IFeatureLayerPtr(_result, false);
}

#pragma implementation_key(1317)
inline long IFeatureLayerPickResult::GetFeatureId ( ) {
    long _result = 0;
    HRESULT _hr = get_FeatureId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface I3DTileLayerPickResult wrapper method implementations
//

#pragma implementation_key(1318)
inline I3DTileLayerPtr I3DTileLayerPickResult::GetTileLayer ( ) {
    struct I3DTileLayer * _result = 0;
    HRESULT _hr = get_TileLayer(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return I3DTileLayerPtr(_result, false);
}

#pragma implementation_key(1319)
inline __int64 I3DTileLayerPickResult::GetTileId ( ) {
    __int64 _result = 0;
    HRESULT _hr = get_TileId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IReferencePlanePickResult wrapper method implementations
//

#pragma implementation_key(1320)
inline IReferencePlanePtr IReferencePlanePickResult::GetReferencePlane ( ) {
    struct IReferencePlane * _result = 0;
    HRESULT _hr = get_ReferencePlane(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IReferencePlanePtr(_result, false);
}

//
// interface ITerrainPickResult wrapper method implementations
//

#pragma implementation_key(1321)
inline ITerrainPtr ITerrainPickResult::GetTerrain ( ) {
    struct ITerrain * _result = 0;
    HRESULT _hr = get_Terrain(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainPtr(_result, false);
}

//
// interface IRenderModelPointPickResult wrapper method implementations
//

#pragma implementation_key(1322)
inline IRenderModelPointPtr IRenderModelPointPickResult::GetModelPoint ( ) {
    struct IRenderModelPoint * _result = 0;
    HRESULT _hr = get_ModelPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderModelPointPtr(_result, false);
}

#pragma implementation_key(1323)
inline long IRenderModelPointPickResult::GetDrawGroupIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_DrawGroupIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1324)
inline long IRenderModelPointPickResult::GetPrimitiveIndex ( ) {
    long _result = 0;
    HRESULT _hr = get_PrimitiveIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IRenderPolylinePickResult wrapper method implementations
//

#pragma implementation_key(1325)
inline IRenderPolylinePtr IRenderPolylinePickResult::GetPolyline ( ) {
    struct IRenderPolyline * _result = 0;
    HRESULT _hr = get_Polyline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPolylinePtr(_result, false);
}

//
// interface IRenderPolygonPickResult wrapper method implementations
//

#pragma implementation_key(1326)
inline IRenderPolygonPtr IRenderPolygonPickResult::GetPolygon ( ) {
    struct IRenderPolygon * _result = 0;
    HRESULT _hr = get_Polygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPolygonPtr(_result, false);
}

//
// interface IRenderTriMeshPickResult wrapper method implementations
//

#pragma implementation_key(1327)
inline IRenderTriMeshPtr IRenderTriMeshPickResult::GetTriMesh ( ) {
    struct IRenderTriMesh * _result = 0;
    HRESULT _hr = get_TriMesh(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderTriMeshPtr(_result, false);
}

//
// interface IRenderMultiTriMeshPickResult wrapper method implementations
//

#pragma implementation_key(1328)
inline IRenderMultiTriMeshPtr IRenderMultiTriMeshPickResult::GetMultiTriMesh ( ) {
    struct IRenderMultiTriMesh * _result = 0;
    HRESULT _hr = get_MultiTriMesh(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiTriMeshPtr(_result, false);
}

//
// interface IRenderMultiPointPickResult wrapper method implementations
//

#pragma implementation_key(1329)
inline IRenderMultiPointPtr IRenderMultiPointPickResult::GetMultiPoint ( ) {
    struct IRenderMultiPoint * _result = 0;
    HRESULT _hr = get_MultiPoint(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiPointPtr(_result, false);
}

//
// interface IRenderMultiPolylinePickResult wrapper method implementations
//

#pragma implementation_key(1330)
inline IRenderMultiPolylinePtr IRenderMultiPolylinePickResult::GetMultiPolyline ( ) {
    struct IRenderMultiPolyline * _result = 0;
    HRESULT _hr = get_MultiPolyline(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiPolylinePtr(_result, false);
}

//
// interface IRenderMultiPolygonPickResult wrapper method implementations
//

#pragma implementation_key(1331)
inline IRenderMultiPolygonPtr IRenderMultiPolygonPickResult::GetMultiPolygon ( ) {
    struct IRenderMultiPolygon * _result = 0;
    HRESULT _hr = get_MultiPolygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderMultiPolygonPtr(_result, false);
}

//
// interface IRenderPointPickResult wrapper method implementations
//

#pragma implementation_key(1332)
inline IRenderPointPtr IRenderPointPickResult::GetPoint ( ) {
    struct IRenderPoint * _result = 0;
    HRESULT _hr = get_Point(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderPointPtr(_result, false);
}

//
// interface ILabelPickResult wrapper method implementations
//

#pragma implementation_key(1333)
inline ILabelPtr ILabelPickResult::GetLabel ( ) {
    struct ILabel * _result = 0;
    HRESULT _hr = get_Label(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ILabelPtr(_result, false);
}

//
// interface ITableLabelPickResult wrapper method implementations
//

#pragma implementation_key(1334)
inline ITableLabelPtr ITableLabelPickResult::GetTableLabel ( ) {
    struct ITableLabel * _result = 0;
    HRESULT _hr = get_TableLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITableLabelPtr(_result, false);
}

//
// interface IOverlayLabelPickResult wrapper method implementations
//

#pragma implementation_key(1335)
inline IOverlayLabelPtr IOverlayLabelPickResult::GetOverlayLabel ( ) {
    struct IOverlayLabel * _result = 0;
    HRESULT _hr = get_OverlayLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IOverlayLabelPtr(_result, false);
}

//
// interface IParticleEffectPickResult wrapper method implementations
//

#pragma implementation_key(1336)
inline IParticleEffectPtr IParticleEffectPickResult::GetParticleEffect ( ) {
    struct IParticleEffect * _result = 0;
    HRESULT _hr = get_ParticleEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IParticleEffectPtr(_result, false);
}

//
// interface ISkinnedMeshPickResult wrapper method implementations
//

#pragma implementation_key(1337)
inline ISkinnedMeshPtr ISkinnedMeshPickResult::GetSkinnedMesh ( ) {
    struct ISkinnedMesh * _result = 0;
    HRESULT _hr = get_SkinnedMesh(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ISkinnedMeshPtr(_result, false);
}

//
// interface IValueMapTextRender wrapper method implementations
//

#pragma implementation_key(1338)
inline HRESULT IValueMapTextRender::AddScheme ( struct ITextRenderScheme * Scheme ) {
    HRESULT _hr = raw_AddScheme(Scheme);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1339)
inline HRESULT IValueMapTextRender::ClearSchemes ( ) {
    HRESULT _hr = raw_ClearSchemes();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1340)
inline ITextRenderSchemePtr IValueMapTextRender::GetScheme ( long Index ) {
    struct ITextRenderScheme * _result = 0;
    HRESULT _hr = raw_GetScheme(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextRenderSchemePtr(_result, false);
}

#pragma implementation_key(1341)
inline long IValueMapTextRender::GetSchemeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_SchemeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IValueMapGeometryRender wrapper method implementations
//

#pragma implementation_key(1342)
inline HRESULT IValueMapGeometryRender::AddScheme ( struct IGeometryRenderScheme * Scheme ) {
    HRESULT _hr = raw_AddScheme(Scheme);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1343)
inline HRESULT IValueMapGeometryRender::ClearSchemes ( ) {
    HRESULT _hr = raw_ClearSchemes();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1344)
inline IGeometryRenderSchemePtr IValueMapGeometryRender::GetScheme ( long Index ) {
    struct IGeometryRenderScheme * _result = 0;
    HRESULT _hr = raw_GetScheme(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometryRenderSchemePtr(_result, false);
}

#pragma implementation_key(1345)
inline long IValueMapGeometryRender::GetSchemeCount ( ) {
    long _result = 0;
    HRESULT _hr = get_SchemeCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface ISimpleTextRender wrapper method implementations
//

#pragma implementation_key(1346)
inline ITextSymbolPtr ISimpleTextRender::GetSymbol ( ) {
    struct ITextSymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITextSymbolPtr(_result, false);
}

#pragma implementation_key(1347)
inline void ISimpleTextRender::PutSymbol ( struct ITextSymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISimpleGeometryRender wrapper method implementations
//

#pragma implementation_key(1348)
inline IGeometrySymbolPtr ISimpleGeometryRender::GetSymbol ( ) {
    struct IGeometrySymbol * _result = 0;
    HRESULT _hr = get_Symbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IGeometrySymbolPtr(_result, false);
}

#pragma implementation_key(1349)
inline void ISimpleGeometryRender::PutSymbol ( struct IGeometrySymbol * pVal ) {
    HRESULT _hr = put_Symbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISolidSymbol wrapper method implementations
//

#pragma implementation_key(1350)
inline OLE_COLOR ISolidSymbol::GetColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_Color(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1351)
inline void ISolidSymbol::PutColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_Color(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1352)
inline ICurveSymbolPtr ISolidSymbol::GetBoundarySymbol ( ) {
    struct ICurveSymbol * _result = 0;
    HRESULT _hr = get_BoundarySymbol(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICurveSymbolPtr(_result, false);
}

#pragma implementation_key(1353)
inline void ISolidSymbol::PutBoundarySymbol ( struct ICurveSymbol * pVal ) {
    HRESULT _hr = put_BoundarySymbol(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ISimplePointSymbol wrapper method implementations
//

#pragma implementation_key(1354)
inline OLE_COLOR ISimplePointSymbol::GetFillColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_FillColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1355)
inline void ISimplePointSymbol::PutFillColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_FillColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1356)
inline OLE_COLOR ISimplePointSymbol::GetOutlineColor ( ) {
    OLE_COLOR _result;
    HRESULT _hr = get_OutlineColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1357)
inline void ISimplePointSymbol::PutOutlineColor ( OLE_COLOR pVal ) {
    HRESULT _hr = put_OutlineColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1358)
inline enum gviSimplePointStyle ISimplePointSymbol::GetStyle ( ) {
    enum gviSimplePointStyle _result;
    HRESULT _hr = get_Style(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1359)
inline void ISimplePointSymbol::PutStyle ( enum gviSimplePointStyle pVal ) {
    HRESULT _hr = put_Style(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IImagePointSymbol wrapper method implementations
//

#pragma implementation_key(1360)
inline _bstr_t IImagePointSymbol::GetImageName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ImageName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1361)
inline void IImagePointSymbol::PutImageName ( _bstr_t pVal ) {
    HRESULT _hr = put_ImageName(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IRangeRenderRule wrapper method implementations
//

#pragma implementation_key(1362)
inline double IRangeRenderRule::GetMinValue ( ) {
    double _result = 0;
    HRESULT _hr = get_MinValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1363)
inline void IRangeRenderRule::PutMinValue ( double pVal ) {
    HRESULT _hr = put_MinValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1364)
inline double IRangeRenderRule::GetMaxValue ( ) {
    double _result = 0;
    HRESULT _hr = get_MaxValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1365)
inline void IRangeRenderRule::PutMaxValue ( double pVal ) {
    HRESULT _hr = put_MaxValue(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1366)
inline VARIANT_BOOL IRangeRenderRule::GetIncludeMin ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeMin(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1367)
inline void IRangeRenderRule::PutIncludeMin ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_IncludeMin(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1368)
inline VARIANT_BOOL IRangeRenderRule::GetIncludeMax ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IncludeMax(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1369)
inline void IRangeRenderRule::PutIncludeMax ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_IncludeMax(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IUniqueValuesRenderRule wrapper method implementations
//

#pragma implementation_key(1370)
inline HRESULT IUniqueValuesRenderRule::AddValue ( _bstr_t newValue ) {
    HRESULT _hr = raw_AddValue(newValue);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1371)
inline HRESULT IUniqueValuesRenderRule::Clear ( ) {
    HRESULT _hr = raw_Clear();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1372)
inline _bstr_t IUniqueValuesRenderRule::GetValue ( long Index ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetValue(Index, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1373)
inline long IUniqueValuesRenderRule::GetCount ( ) {
    long _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IMotionable wrapper method implementations
//

#pragma implementation_key(1374)
inline HRESULT IMotionable::Bind ( struct IMotionPath * Path, struct IVector3 * PosOffset, double HeadingOffset, double PitchOffset, double RollOffset ) {
    HRESULT _hr = raw_Bind(Path, PosOffset, HeadingOffset, PitchOffset, RollOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1375)
inline HRESULT IMotionable::Unbind ( ) {
    HRESULT _hr = raw_Unbind();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1376)
inline GUID IMotionable::GetMotionPathId ( ) {
    GUID _result;
    HRESULT _hr = raw_GetMotionPathId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1377)
inline HRESULT IMotionable::Bind2 ( struct IDynamicObject * Path, struct IVector3 * PosOffset, double HeadingOffset, double PitchOffset, double RollOffset ) {
    HRESULT _hr = raw_Bind2(Path, PosOffset, HeadingOffset, PitchOffset, RollOffset);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface ITerrainHolePickResult wrapper method implementations
//

#pragma implementation_key(1378)
inline ITerrainHolePtr ITerrainHolePickResult::GetTerrainHole ( ) {
    struct ITerrainHole * _result = 0;
    HRESULT _hr = get_TerrainHole(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainHolePtr(_result, false);
}

//
// interface ITileHolePickResult wrapper method implementations
//

#pragma implementation_key(1379)
inline I3DTileHolePtr ITileHolePickResult::GetTileHole ( ) {
    struct I3DTileHole * _result = 0;
    HRESULT _hr = get_TileHole(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return I3DTileHolePtr(_result, false);
}

//
// interface IRenderArrowPickResult wrapper method implementations
//

#pragma implementation_key(1380)
inline IRenderArrowPtr IRenderArrowPickResult::GetRenderArrow ( ) {
    struct IRenderArrow * _result = 0;
    HRESULT _hr = get_RenderArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IRenderArrowPtr(_result, false);
}

//
// interface IWindowParam wrapper method implementations
//

#pragma implementation_key(1381)
inline _bstr_t IWindowParam::GetFilePath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_FilePath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1382)
inline void IWindowParam::PutFilePath ( _bstr_t pVal ) {
    HRESULT _hr = put_FilePath(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1383)
inline enum gviHTMLWindowPosition IWindowParam::GetPosition ( ) {
    enum gviHTMLWindowPosition _result;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1384)
inline void IWindowParam::PutPosition ( enum gviHTMLWindowPosition pVal ) {
    HRESULT _hr = put_Position(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1385)
inline long IWindowParam::GetOffsetX ( ) {
    long _result = 0;
    HRESULT _hr = get_OffsetX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1386)
inline void IWindowParam::PutOffsetX ( long pVal ) {
    HRESULT _hr = put_OffsetX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1387)
inline long IWindowParam::GetOffsetY ( ) {
    long _result = 0;
    HRESULT _hr = get_OffsetY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1388)
inline void IWindowParam::PutOffsetY ( long pVal ) {
    HRESULT _hr = put_OffsetY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1389)
inline long IWindowParam::GetSizeX ( ) {
    long _result = 0;
    HRESULT _hr = get_SizeX(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1390)
inline void IWindowParam::PutSizeX ( long pVal ) {
    HRESULT _hr = put_SizeX(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1391)
inline long IWindowParam::GetSizeY ( ) {
    long _result = 0;
    HRESULT _hr = get_SizeY(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1392)
inline void IWindowParam::PutSizeY ( long pVal ) {
    HRESULT _hr = put_SizeY(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1393)
inline VARIANT_BOOL IWindowParam::GetShowWindow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ShowWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1394)
inline void IWindowParam::PutShowWindow ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_ShowWindow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1395)
inline VARIANT_BOOL IWindowParam::GetHastitle ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Hastitle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1396)
inline void IWindowParam::PutHastitle ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Hastitle(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1397)
inline VARIANT_BOOL IWindowParam::GetHideOnClick ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_HideOnClick(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1398)
inline void IWindowParam::PutHideOnClick ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_HideOnClick(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1399)
inline _bstr_t IWindowParam::GetResetOnHide ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ResetOnHide(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1400)
inline void IWindowParam::PutResetOnHide ( _bstr_t pVal ) {
    HRESULT _hr = put_ResetOnHide(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1401)
inline long IWindowParam::GetWinId ( ) {
    long _result = 0;
    HRESULT _hr = get_WinId(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1402)
inline void IWindowParam::PutWinId ( long pVal ) {
    HRESULT _hr = put_WinId(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1403)
inline long IWindowParam::GetRound ( ) {
    long _result = 0;
    HRESULT _hr = get_Round(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1404)
inline void IWindowParam::PutRound ( long pVal ) {
    HRESULT _hr = put_Round(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1405)
inline unsigned char IWindowParam::GetTransparence ( ) {
    unsigned char _result = 0;
    HRESULT _hr = get_Transparence(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1406)
inline void IWindowParam::PutTransparence ( unsigned char pVal ) {
    HRESULT _hr = put_Transparence(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1407)
inline _bstr_t IWindowParam::GetRgnTemplateFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_RgnTemplateFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1408)
inline void IWindowParam::PutRgnTemplateFile ( _bstr_t pVal ) {
    HRESULT _hr = put_RgnTemplateFile(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1409)
inline unsigned long IWindowParam::GetRgnTransparentColor ( ) {
    unsigned long _result = 0;
    HRESULT _hr = get_RgnTransparentColor(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1410)
inline void IWindowParam::PutRgnTransparentColor ( unsigned long pVal ) {
    HRESULT _hr = put_RgnTransparentColor(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1411)
inline VARIANT_BOOL IWindowParam::GetCloseButtonEnabled ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_CloseButtonEnabled(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1412)
inline void IWindowParam::PutCloseButtonEnabled ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_CloseButtonEnabled(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1413)
inline VARIANT_BOOL IWindowParam::GetMinButtonVisible ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_MinButtonVisible(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1414)
inline void IWindowParam::PutMinButtonVisible ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_MinButtonVisible(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1415)
inline VARIANT_BOOL IWindowParam::GetIsPopupWindow ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsPopupWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1416)
inline void IWindowParam::PutIsPopupWindow ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_IsPopupWindow(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

#pragma implementation_key(1417)
inline VARIANT_BOOL IWindowParam::GetResizable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Resizable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1418)
inline void IWindowParam::PutResizable ( VARIANT_BOOL pVal ) {
    HRESULT _hr = put_Resizable(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IHTMLWindow wrapper method implementations
//

#pragma implementation_key(1419)
inline HRESULT IHTMLWindow::ShowPopupWindow ( _bstr_t URL, long SizeX, long SizeY, VARIANT_BOOL Hastitle, enum gviHTMLWindowPosition Position, long Round ) {
    HRESULT _hr = raw_ShowPopupWindow(URL, SizeX, SizeY, Hastitle, Position, Round);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1420)
inline HRESULT IHTMLWindow::ShowPopupWindowEx ( struct IPoint * Position, struct IWindowParam * Param, VARIANT_BOOL AutoComputePos ) {
    HRESULT _hr = raw_ShowPopupWindowEx(Position, Param, AutoComputePos);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1421)
inline HRESULT IHTMLWindow::DeletePopupWindow ( long WinId ) {
    HRESULT _hr = raw_DeletePopupWindow(WinId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1422)
inline HRESULT IHTMLWindow::SetWindowSize ( long Width, long Height, long WinId ) {
    HRESULT _hr = raw_SetWindowSize(Width, Height, WinId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1423)
inline HRESULT IHTMLWindow::HideWindow ( long WinId ) {
    HRESULT _hr = raw_HideWindow(WinId);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1424)
inline IWindowParamPtr IHTMLWindow::CreateWindowParam ( ) {
    struct IWindowParam * _result = 0;
    HRESULT _hr = raw_CreateWindowParam(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IWindowParamPtr(_result, false);
}

#pragma implementation_key(1425)
inline HRESULT IHTMLWindow::SetWindowParam ( struct IWindowParam * Param ) {
    HRESULT _hr = raw_SetWindowParam(Param);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface IPolygon3DSymbol wrapper method implementations
//

#pragma implementation_key(1426)
inline double IPolygon3DSymbol::GetHeight ( ) {
    double _result = 0;
    HRESULT _hr = get_Height(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1427)
inline void IPolygon3DSymbol::PutHeight ( double pVal ) {
    HRESULT _hr = put_Height(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface ITerrainModifierPickResult wrapper method implementations
//

#pragma implementation_key(1428)
inline ITerrainModifierPtr ITerrainModifierPickResult::GetTerrainModifier ( ) {
    struct ITerrainModifier * _result = 0;
    HRESULT _hr = get_TerrainModifier(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainModifierPtr(_result, false);
}

//
// interface ITerrainArrowPickResult wrapper method implementations
//

#pragma implementation_key(1429)
inline ITerrainArrowPtr ITerrainArrowPickResult::GetTerrainArrow ( ) {
    struct ITerrainArrow * _result = 0;
    HRESULT _hr = get_TerrainArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainArrowPtr(_result, false);
}

//
// interface ITerrain3DArrowPickResult wrapper method implementations
//

#pragma implementation_key(1430)
inline ITerrain3DArrowPtr ITerrain3DArrowPickResult::GetTerrain3DArrow ( ) {
    struct ITerrain3DArrow * _result = 0;
    HRESULT _hr = get_Terrain3DArrow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DArrowPtr(_result, false);
}

//
// interface ITerrainRegularPolygonPickResult wrapper method implementations
//

#pragma implementation_key(1431)
inline ITerrainRegularPolygonPtr ITerrainRegularPolygonPickResult::GetTerrainRegularPolygon ( ) {
    struct ITerrainRegularPolygon * _result = 0;
    HRESULT _hr = get_TerrainRegularPolygon(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainRegularPolygonPtr(_result, false);
}

//
// interface ITerrainCylinderPickResult wrapper method implementations
//

#pragma implementation_key(1432)
inline ITerrain3DRegBasePtr ITerrainCylinderPickResult::GetTerrainCylinder ( ) {
    struct ITerrain3DRegBase * _result = 0;
    HRESULT _hr = get_TerrainCylinder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRegBasePtr(_result, false);
}

//
// interface ITerrainConePickResult wrapper method implementations
//

#pragma implementation_key(1433)
inline ITerrain3DRegBasePtr ITerrainConePickResult::GetTerrainCone ( ) {
    struct ITerrain3DRegBase * _result = 0;
    HRESULT _hr = get_TerrainCone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRegBasePtr(_result, false);
}

//
// interface ITerrainRectanglePickResult wrapper method implementations
//

#pragma implementation_key(1434)
inline ITerrainRectanglePtr ITerrainRectanglePickResult::GetTerrainRectangle ( ) {
    struct ITerrainRectangle * _result = 0;
    HRESULT _hr = get_TerrainRectangle(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainRectanglePtr(_result, false);
}

//
// interface ITerrainBoxPickResult wrapper method implementations
//

#pragma implementation_key(1435)
inline ITerrain3DRectBasePtr ITerrainBoxPickResult::GetTerrainBox ( ) {
    struct ITerrain3DRectBase * _result = 0;
    HRESULT _hr = get_TerrainBox(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRectBasePtr(_result, false);
}

//
// interface ITerrainPyramidPickResult wrapper method implementations
//

#pragma implementation_key(1436)
inline ITerrain3DRectBasePtr ITerrainPyramidPickResult::GetTerrainPyramid ( ) {
    struct ITerrain3DRectBase * _result = 0;
    HRESULT _hr = get_TerrainPyramid(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrain3DRectBasePtr(_result, false);
}

//
// interface ITerrainEllipsePickResult wrapper method implementations
//

#pragma implementation_key(1437)
inline ITerrainEllipsePtr ITerrainEllipsePickResult::GetTerrainEllipse ( ) {
    struct ITerrainEllipse * _result = 0;
    HRESULT _hr = get_TerrainEllipse(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainEllipsePtr(_result, false);
}

//
// interface ITerrainArcPickResult wrapper method implementations
//

#pragma implementation_key(1438)
inline ITerrainArcPtr ITerrainArcPickResult::GetTerrainArc ( ) {
    struct ITerrainArc * _result = 0;
    HRESULT _hr = get_TerrainArc(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainArcPtr(_result, false);
}

//
// interface ITerrainSpherePickResult wrapper method implementations
//

#pragma implementation_key(1439)
inline ITerrainSpherePtr ITerrainSpherePickResult::GetTerrainSphere ( ) {
    struct ITerrainSphere * _result = 0;
    HRESULT _hr = get_TerrainSphere(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainSpherePtr(_result, false);
}

//
// interface ITerrainImageLabelPickResult wrapper method implementations
//

#pragma implementation_key(1440)
inline ITerrainImageLabelPtr ITerrainImageLabelPickResult::GetTerrainImageLabel ( ) {
    struct ITerrainImageLabel * _result = 0;
    HRESULT _hr = get_TerrainImageLabel(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ITerrainImageLabelPtr(_result, false);
}

//
// interface IComplexParticleEffectPickResult wrapper method implementations
//

#pragma implementation_key(1441)
inline IComplexParticleEffectPtr IComplexParticleEffectPickResult::GetComplexParticleEffect ( ) {
    struct IComplexParticleEffect * _result = 0;
    HRESULT _hr = get_ComplexParticleEffect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IComplexParticleEffectPtr(_result, false);
}

//
// interface IUIWindowEventArgs wrapper method implementations
//

#pragma implementation_key(1442)
inline IUIWindowPtr IUIWindowEventArgs::GetUIWindow ( ) {
    struct IUIWindow * _result = 0;
    HRESULT _hr = get_UIWindow(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUIWindowPtr(_result, false);
}

//
// interface IUIMouseEventArgs wrapper method implementations
//

#pragma implementation_key(1443)
inline long IUIMouseEventArgs::GetClickCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ClickCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1444)
inline long IUIMouseEventArgs::GetSysKeys ( ) {
    long _result = 0;
    HRESULT _hr = get_SysKeys(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1445)
inline float IUIMouseEventArgs::GetWheelChange ( ) {
    float _result = 0;
    HRESULT _hr = get_WheelChange(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1446)
inline enum gviUIMouseButtonType IUIMouseEventArgs::GetButton ( ) {
    enum gviUIMouseButtonType _result;
    HRESULT _hr = get_Button(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1447)
inline SAFEARRAY * IUIMouseEventArgs::GetMoveDelta ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_MoveDelta(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1448)
inline SAFEARRAY * IUIMouseEventArgs::GetPosition ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Position(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IInternalTool wrapper method implementations
//

#pragma implementation_key(1449)
inline HRESULT IInternalTool::SetCursorPos ( long X, long Y ) {
    HRESULT _hr = raw_SetCursorPos(X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1450)
inline HRESULT IInternalTool::DoMouseEvent ( unsigned char MouseButton, long X, long Y ) {
    HRESULT _hr = raw_DoMouseEvent(MouseButton, X, Y);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1451)
inline VARIANT_BOOL IInternalTool::CaptureWindow ( _bstr_t ImagePath ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_CaptureWindow(ImagePath, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1452)
inline HRESULT IInternalTool::CoordClientToScreen ( long X, long Y, long * OutX, long * OutY ) {
    HRESULT _hr = raw_CoordClientToScreen(X, Y, OutX, OutY);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1453)
inline float IInternalTool::CompareImage ( long Id, _bstr_t Image1, _bstr_t Image2 ) {
    float _result = 0;
    HRESULT _hr = raw_CompareImage(Id, Image1, Image2, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1454)
inline _bstr_t IInternalTool::GetRuntimeTempPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = raw_GetRuntimeTempPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

#pragma implementation_key(1455)
inline HRESULT IInternalTool::IsFirefox ( VARIANT_BOOL newVal ) {
    HRESULT _hr = raw_IsFirefox(newVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

#pragma implementation_key(1456)
inline long IInternalTool::GetMsgChainFlags ( ) {
    long _result = 0;
    HRESULT _hr = get_MsgChainFlags(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

#pragma implementation_key(1457)
inline void IInternalTool::PutMsgChainFlags ( long pVal ) {
    HRESULT _hr = put_MsgChainFlags(pVal);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface IInternalLicenseKey wrapper method implementations
//

#pragma implementation_key(1458)
inline long IInternalLicenseKey::SetLicenseKey ( _bstr_t newVal ) {
    long _result = 0;
    HRESULT _hr = raw_SetLicenseKey(newVal, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface IReferenceHelper wrapper method implementations
//

#pragma implementation_key(1459)
inline IDataInteropPtr IReferenceHelper::GetDataInterop ( ) {
    struct IDataInterop * _result = 0;
    HRESULT _hr = get_DataInterop(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IDataInteropPtr(_result, false);
}

#pragma implementation_key(1460)
inline ICommandManagerPtr IReferenceHelper::GetCommandManager ( ) {
    struct ICommandManager * _result = 0;
    HRESULT _hr = get_CommandManager(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ICommandManagerPtr(_result, false);
}
